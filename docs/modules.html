

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>PyOR Source Code &mdash; PyOR 1.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=92fd9be5" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="_static/plot_directive.css" />

  
    <link rel="canonical" href="https://vthalakottoor.github.io/PyOR/modules.html" />
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=8d563738"></script>
      <script src="_static/doctools.js?v=9a2dae69"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="PyOR Simulation Examples" href="examples.html" />
    <link rel="prev" title="Welcome to PyOR’s Documentation!" href="index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            PyOR
              <img src="_static/logo_3.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Source Code</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">PyOR Source Code</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#basis-module">Basis Module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#basis"><code class="xref py py-mod docutils literal notranslate"><span class="pre">Basis</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#coherence-filters-module">Coherence Filters Module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#coherencefilters"><code class="xref py py-mod docutils literal notranslate"><span class="pre">CoherenceFilters</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#commutators-module">Commutators Module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#commutators"><code class="xref py py-mod docutils literal notranslate"><span class="pre">Commutators</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#crystal-orientation-module">Crystal Orientation Module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#crystalorientation"><code class="xref py py-mod docutils literal notranslate"><span class="pre">CrystalOrientation</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#density-matrix-module">Density Matrix Module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#densitymatrix"><code class="xref py py-mod docutils literal notranslate"><span class="pre">DensityMatrix</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#evolution-module">Evolution Module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#evolution"><code class="xref py py-mod docutils literal notranslate"><span class="pre">Evolution</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#fitting-module">Fitting Module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#fitting"><code class="xref py py-mod docutils literal notranslate"><span class="pre">Fitting</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#gamma-module">Gamma Module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#gamma"><code class="xref py py-mod docutils literal notranslate"><span class="pre">Gamma</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#hamiltonian-module">Hamiltonian Module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#hamiltonian"><code class="xref py py-mod docutils literal notranslate"><span class="pre">Hamiltonian</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#hard-pulse-module">Hard Pulse Module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#hardpulse"><code class="xref py py-mod docutils literal notranslate"><span class="pre">HardPulse</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#maser-data-analyzer-module">Maser Data Analyzer Module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#maserdataanalyzer"><code class="xref py py-mod docutils literal notranslate"><span class="pre">MaserDataAnalyzer</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#nonlinear-nmr-module">Nonlinear NMR Module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#nonlinearnmr"><code class="xref py py-mod docutils literal notranslate"><span class="pre">NonlinearNMR</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#particle-module">Particle Module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#particle"><code class="xref py py-mod docutils literal notranslate"><span class="pre">Particle</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#phase-cycle-module">Phase Cycle Module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#phasecycle"><code class="xref py py-mod docutils literal notranslate"><span class="pre">PhaseCycle</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#physical-constants-module">Physical Constants Module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#physicalconstants"><code class="xref py py-mod docutils literal notranslate"><span class="pre">PhysicalConstants</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#plotting-module">Plotting Module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#plotting"><code class="xref py py-mod docutils literal notranslate"><span class="pre">Plotting</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#probability-density-functions-module">Probability Density Functions Module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#probabilitydensityfunctions"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ProbabilityDensityFunctions</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#quadrupole-moment-module">Quadrupole Moment Module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#quadrupolemoment"><code class="xref py py-mod docutils literal notranslate"><span class="pre">QuadrupoleMoment</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#quantum-library-module">Quantum Library Module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#quantumlibrary"><code class="xref py py-mod docutils literal notranslate"><span class="pre">QuantumLibrary</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#quantum-object-module">Quantum Object Module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#quantumobject"><code class="xref py py-mod docutils literal notranslate"><span class="pre">QuantumObject</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#quantum-system-module">Quantum System Module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#quantumsystem"><code class="xref py py-mod docutils literal notranslate"><span class="pre">QuantumSystem</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#relaxation-module">Relaxation Module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#relaxation"><code class="xref py py-mod docutils literal notranslate"><span class="pre">Relaxation</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rotation-module">Rotation Module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#rotation"><code class="xref py py-mod docutils literal notranslate"><span class="pre">Rotation</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#signal-processing-module">Signal Processing Module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#signalprocessing"><code class="xref py py-mod docutils literal notranslate"><span class="pre">SignalProcessing</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#spherical-tensors-module">Spherical Tensors Module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#sphericaltensors"><code class="xref py py-mod docutils literal notranslate"><span class="pre">SphericalTensors</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#spin-quantum-number-module">Spin Quantum Number Module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#spinquantumnumber"><code class="xref py py-mod docutils literal notranslate"><span class="pre">SpinQuantumNumber</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Examples</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="examples.html">PyOR Simulation Examples</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">PyOR</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">PyOR Source Code</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/modules.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="pyor-source-code">
<h1>PyOR Source Code<a class="headerlink" href="#pyor-source-code" title="Link to this heading"></a></h1>
<section id="basis-module">
<h2>Basis Module<a class="headerlink" href="#basis-module" title="Link to this heading"></a></h2>
<section id="basis">
<h3><code class="xref py py-mod docutils literal notranslate"><span class="pre">Basis</span></code><a class="headerlink" href="#basis" title="Link to this heading"></a></h3>
<p>PyOR Python On Resonance</p>
<p>Author: Vineeth Francis Thalakottoor Jose Chacko</p>
<p>Email: <a class="reference external" href="mailto:vineethfrancis&#46;physics&#37;&#52;&#48;gmail&#46;com">vineethfrancis<span>&#46;</span>physics<span>&#64;</span>gmail<span>&#46;</span>com</a></p>
<dl class="simple">
<dt>Description:</dt><dd><p>This file contains the class <cite>Basis</cite>.</p>
</dd>
</dl>
<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">class_QS</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Basis.html#Basis"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Adjoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Basis.html#Basis.Adjoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute the adjoint (Hermitian conjugate) of an operator.</p>
<section id="parameters">
<h4>Parameters<a class="headerlink" href="#parameters" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>A<span class="classifier">ndarray</span></dt><dd><p>Operator or state vector.</p>
</dd>
</dl>
</section>
<section id="returns">
<h4>Returns<a class="headerlink" href="#returns" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>ndarray</dt><dd><p>Hermitian conjugate of the input.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BasisChange_Operator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">O</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Basis.html#Basis.BasisChange_Operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Transform an operator using the given transformation matrix.</p>
<section id="id1">
<h4>Parameters<a class="headerlink" href="#id1" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>O<span class="classifier">QunObj</span></dt><dd><p>Operator in the original basis.</p>
</dd>
<dt>U<span class="classifier">QunObj</span></dt><dd><p>Transformation matrix.</p>
</dd>
</dl>
</section>
<section id="id2">
<h4>Returns<a class="headerlink" href="#id2" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>QunObj</dt><dd><p>Operator in the new basis.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BasisChange_SpinOperators</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Sop</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Basis.html#Basis.BasisChange_SpinOperators"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Transform a list of spin operators using a transformation matrix.</p>
<section id="id3">
<h4>Parameters<a class="headerlink" href="#id3" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>Sop<span class="classifier">list of QunObj</span></dt><dd><p>Spin operators in the original basis.</p>
</dd>
<dt>U<span class="classifier">QunObj</span></dt><dd><p>Transformation matrix.</p>
</dd>
</dl>
</section>
<section id="id4">
<h4>Returns<a class="headerlink" href="#id4" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>np.ndarray</dt><dd><p>Transformed spin operators.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BasisChange_State</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Basis.html#Basis.BasisChange_State"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Transform a state vector using the given transformation matrix.</p>
<section id="id5">
<h4>Parameters<a class="headerlink" href="#id5" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>state<span class="classifier">QunObj</span></dt><dd><p>State in the original basis.</p>
</dd>
<dt>U<span class="classifier">QunObj</span></dt><dd><p>Transformation matrix.</p>
</dd>
</dl>
</section>
<section id="id6">
<h4>Returns<a class="headerlink" href="#id6" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>QunObj</dt><dd><p>State in the new basis.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BasisChange_States</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">states</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Basis.html#Basis.BasisChange_States"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Transform one or more state vectors using the given transformation matrix.</p>
<section id="id7">
<h4>Parameters<a class="headerlink" href="#id7" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>states<span class="classifier">QunObj or list of QunObj</span></dt><dd><p>State(s) in the original basis.</p>
</dd>
<dt>U<span class="classifier">QunObj</span></dt><dd><p>Transformation matrix.</p>
</dd>
</dl>
</section>
<section id="id8">
<h4>Returns<a class="headerlink" href="#id8" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>QunObj or list of QunObj</dt><dd><p>State(s) in the new basis.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BasisChange_TransformationMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">old</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">new</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Basis.html#Basis.BasisChange_TransformationMatrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute the transformation matrix between two basis sets.</p>
<p>The transformation matrix <span class="math notranslate nohighlight">\(U\)</span> satisfies:
<span class="math notranslate nohighlight">\(| \text{new} \rangle = U | \text{old} \rangle\)</span> and <span class="math notranslate nohighlight">\(O_{\text{new}} = U O_{\text{old}} U^\dagger\)</span></p>
<section id="id9">
<h4>Parameters<a class="headerlink" href="#id9" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>old<span class="classifier">list of QunObj</span></dt><dd><p>Old basis vectors.</p>
</dd>
<dt>new<span class="classifier">list of QunObj</span></dt><dd><p>New basis vectors.</p>
</dd>
</dl>
</section>
<section id="id10">
<h4>Returns<a class="headerlink" href="#id10" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>QunObj</dt><dd><p>Transformation matrix as a QunObj.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Basis_Ket_AngularMomentum_Array</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Basis.html#Basis.Basis_Ket_AngularMomentum_Array"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute magnetic quantum numbers for each Zeeman state.</p>
<section id="id11">
<h4>Returns<a class="headerlink" href="#id11" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>np.ndarray</dt><dd><p>Array of magnetic quantum numbers (diagonal of total Sz).</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Basis_Ket_AngularMomentum_List</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Basis.html#Basis.Basis_Ket_AngularMomentum_List"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute magnetic quantum numbers for each Zeeman state as strings.</p>
<section id="id12">
<h4>Returns<a class="headerlink" href="#id12" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>list of str</dt><dd><p>List of magnetic quantum numbers as fractions.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CG_Coefficient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">J</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Basis.html#Basis.CG_Coefficient"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute the Clebsch-Gordan coefficient ⟨j1 m1 j2 m2 | J M⟩.</p>
<section id="id13">
<h4>Parameters<a class="headerlink" href="#id13" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>j1, m1, j2, m2, J, M<span class="classifier">float or int</span></dt><dd><p>Quantum numbers for the Clebsch-Gordan coefficient.</p>
</dd>
</dl>
</section>
<section id="id14">
<h4>Returns<a class="headerlink" href="#id14" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>float</dt><dd><p>Value of the Clebsch-Gordan coefficient.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InnerProduct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Basis.html#Basis.InnerProduct"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute inner product of two operators.</p>
<section id="id15">
<h4>Parameters<a class="headerlink" href="#id15" title="Link to this heading"></a></h4>
<p>A : ndarray
B : ndarray</p>
</section>
<section id="id16">
<h4>Returns<a class="headerlink" href="#id16" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>complex</dt><dd><p>Inner product Tr(A† B)</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">KetState_Components</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">AQ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dic</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ketQ</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Basis.html#Basis.KetState_Components"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Decompose ket state into basis components.</p>
<section id="id17">
<h4>Parameters<a class="headerlink" href="#id17" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>AQ<span class="classifier">list of QunObj</span></dt><dd><p>Basis ket vectors (assumed orthonormal).</p>
</dd>
<dt>dic<span class="classifier">dict</span></dt><dd><p>Dictionary mapping basis indices to basis labels.</p>
</dd>
<dt>ketQ<span class="classifier">QunObj</span></dt><dd><p>Ket state vector to be decomposed.</p>
</dd>
</dl>
</section>
<section id="id18">
<h4>Returns<a class="headerlink" href="#id18" title="Link to this heading"></a></h4>
<p>None</p>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Normalize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Basis.html#Basis.Normalize"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Normalize an operator so its inner product with itself is 1.</p>
<section id="id19">
<h4>Parameters<a class="headerlink" href="#id19" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>A<span class="classifier">ndarray</span></dt><dd><p>Operator to normalize.</p>
</dd>
</dl>
</section>
<section id="id20">
<h4>Returns<a class="headerlink" href="#id20" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>ndarray</dt><dd><p>Normalized operator.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ProductOperator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">OP1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">CO1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">DIC1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">OP2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">CO2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">DIC2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sort</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indexing</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Basis.html#Basis.ProductOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Perform the Kronecker product of two sets of spherical basis operators.</p>
<section id="id21">
<h4>Parameters<a class="headerlink" href="#id21" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>OP1, OP2<span class="classifier">list of QunObj</span></dt><dd><p>Basis operators of each subsystem.</p>
</dd>
<dt>CO1, CO2<span class="classifier">list of int</span></dt><dd><p>Coherence orders for each subsystem.</p>
</dd>
<dt>DIC1, DIC2<span class="classifier">list of str</span></dt><dd><p>Labels for each subsystem.</p>
</dd>
<dt>sort<span class="classifier">str</span></dt><dd><p>Sorting method for coherence order.</p>
</dd>
<dt>indexing<span class="classifier">bool</span></dt><dd><p>Whether to append indices to the labels.</p>
</dd>
</dl>
</section>
<section id="id22">
<h4>Returns<a class="headerlink" href="#id22" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>list of QunObj</dt><dd><p>Combined operator basis.</p>
</dd>
<dt>list of int</dt><dd><p>Combined coherence orders.</p>
</dd>
<dt>list of str</dt><dd><p>Combined operator labels.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ProductOperators_ConvertToLiouville</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Basis_X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Basis.html#Basis.ProductOperators_ConvertToLiouville"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Convert product operator basis to Liouville space.</p>
<section id="id23">
<h4>Parameters<a class="headerlink" href="#id23" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>Basis_X<span class="classifier">list of QunObj</span></dt><dd><p>Basis in Hilbert space.</p>
</dd>
</dl>
</section>
<section id="id24">
<h4>Returns<a class="headerlink" href="#id24" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>list of QunObj</dt><dd><p>Basis in Liouville space.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ProductOperators_SphericalTensor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sort</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'negative</span> <span class="pre">to</span> <span class="pre">positive'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Basis.html#Basis.ProductOperators_SphericalTensor"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Generate spherical tensor basis for a multi-spin system.</p>
<section id="id25">
<h4>Parameters<a class="headerlink" href="#id25" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>sort<span class="classifier">str, optional</span></dt><dd><p>Sorting option for coherence order (‘normal’, ‘negative to positive’, ‘zero to high’).</p>
</dd>
<dt>Index<span class="classifier">bool, optional</span></dt><dd><p>Whether to append index to labels.</p>
</dd>
</dl>
</section>
<section id="id26">
<h4>Returns<a class="headerlink" href="#id26" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>list of QunObj</dt><dd><p>List of spherical tensor operators for the multi-spin system.</p>
</dd>
<dt>list of int</dt><dd><p>Corresponding coherence orders.</p>
</dd>
<dt>list of str</dt><dd><p>Labels of each basis operator in the form T(L,M).</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ProductOperators_SpinHalf_Cartesian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Normal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Basis.html#Basis.ProductOperators_SpinHalf_Cartesian"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Generate product operator basis in the Cartesian basis for spin-1/2 systems.</p>
<section id="id27">
<h4>Parameters<a class="headerlink" href="#id27" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>Index<span class="classifier">bool, optional</span></dt><dd><p>Whether to include index in labels.</p>
</dd>
<dt>Normal<span class="classifier">bool, optional</span></dt><dd><p>Whether to normalize the operators.</p>
</dd>
</dl>
</section>
<section id="id28">
<h4>Returns<a class="headerlink" href="#id28" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>list of QunObj</dt><dd><p>Product operators.</p>
</dd>
<dt>list of str</dt><dd><p>Corresponding labels.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ProductOperators_SpinHalf_PMZ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sort</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'negative</span> <span class="pre">to</span> <span class="pre">positive'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Normal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Basis.html#Basis.ProductOperators_SpinHalf_PMZ"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Generate product operators for spin-1/2 systems in the PMZ basis.</p>
<section id="id29">
<h4>Parameters<a class="headerlink" href="#id29" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>sort<span class="classifier">str, optional</span></dt><dd><p>Sorting method for coherence order.</p>
</dd>
<dt>Index<span class="classifier">bool, optional</span></dt><dd><p>Whether to include index in labels.</p>
</dd>
<dt>Normal<span class="classifier">bool, optional</span></dt><dd><p>Whether to normalize the operators.</p>
</dd>
</dl>
</section>
<section id="id30">
<h4>Returns<a class="headerlink" href="#id30" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>list of QunObj</dt><dd><p>Product operators.</p>
</dd>
<dt>list of int</dt><dd><p>Coherence orders.</p>
</dd>
<dt>list of str</dt><dd><p>Operator labels.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ProductOperators_SpinHalf_SphericalTensor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sort</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'negative</span> <span class="pre">to</span> <span class="pre">positive'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Basis.html#Basis.ProductOperators_SpinHalf_SphericalTensor"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Generate product operators for spin-1/2 systems in the spherical tensor basis.</p>
<section id="id31">
<h4>Parameters<a class="headerlink" href="#id31" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>sort<span class="classifier">str, optional</span></dt><dd><p>Sorting method for coherence order.</p>
</dd>
<dt>Index<span class="classifier">bool, optional</span></dt><dd><p>Whether to include index in labels.</p>
</dd>
</dl>
</section>
<section id="id32">
<h4>Returns<a class="headerlink" href="#id32" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>list of QunObj</dt><dd><p>Product operators.</p>
</dd>
<dt>list of int</dt><dd><p>Coherence orders.</p>
</dd>
<dt>list of str</dt><dd><p>Operator labels.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ProductOperators_Zeeman</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Basis.html#Basis.ProductOperators_Zeeman"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Generate product operators in the Zeeman basis.</p>
<section id="id33">
<h4>Returns<a class="headerlink" href="#id33" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>list of QunObj</dt><dd><p>Product operators in Zeeman basis.</p>
</dd>
<dt>list of str</dt><dd><p>Operator labels.</p>
</dd>
<dt>list of float</dt><dd><p>Coherence orders.</p>
</dd>
<dt>QunObj</dt><dd><p>Coherence order as a 2D matrix.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SingletTriplet_Basis</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Basis.html#Basis.SingletTriplet_Basis"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Generate singlet-triplet basis for two spin-1/2 particles.</p>
<section id="id34">
<h4>Returns<a class="headerlink" href="#id34" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>list of QunObj</dt><dd><p>Singlet-triplet basis vectors.</p>
</dd>
<dt>list of str</dt><dd><p>Basis labels.</p>
</dd>
</dl>
</section>
<section id="notes">
<h4>Notes<a class="headerlink" href="#notes" title="Link to this heading"></a></h4>
<p>Only works for two spin-1/2 systems.</p>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Spherical_OpBasis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">S</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Basis.html#Basis.Spherical_OpBasis"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Generate spherical tensor operator basis for a single spin.</p>
<section id="id35">
<h4>Parameters<a class="headerlink" href="#id35" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>S<span class="classifier">float</span></dt><dd><p>Spin quantum number.</p>
</dd>
</dl>
</section>
<section id="id36">
<h4>Returns<a class="headerlink" href="#id36" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>list of QunObj</dt><dd><p>Spherical tensor operators.</p>
</dd>
<dt>list of int</dt><dd><p>Corresponding coherence orders.</p>
</dd>
<dt>list of tuple</dt><dd><p>List of (L, M) values.</p>
</dd>
</dl>
</section>
<section id="reference">
<h4>Reference:<a class="headerlink" href="#reference" title="Link to this heading"></a></h4>
<ol class="arabic simple">
<li><p>Quantum Theory of Angular Momentum, D. A. Varshalovich, A. N. Moskalev and V. K. Khersonskii</p></li>
</ol>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">String_to_Matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dic</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Basis</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Basis.html#Basis.String_to_Matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Convert a dictionary of labels to a dictionary mapping labels to matrices.</p>
<section id="id37">
<h4>Parameters<a class="headerlink" href="#id37" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>dic<span class="classifier">list of str</span></dt><dd><p>Dictionary labels for operator basis.</p>
</dd>
<dt>Basis<span class="classifier">list of QunObj</span></dt><dd><p>Corresponding list of operators.</p>
</dd>
</dl>
</section>
<section id="id38">
<h4>Returns<a class="headerlink" href="#id38" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>dict</dt><dd><p>Dictionary mapping cleaned labels to QunObj instances.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Vector_L</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Basis.html#Basis.Vector_L"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Vectorize an operator into Liouville space form.</p>
<section id="id39">
<h4>Parameters<a class="headerlink" href="#id39" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>X<span class="classifier">ndarray</span></dt><dd><p>Operator to vectorize.</p>
</dd>
</dl>
</section>
<section id="id40">
<h4>Returns<a class="headerlink" href="#id40" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>ndarray</dt><dd><p>Vectorized operator.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Zeeman_Basis</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Basis.html#Basis.Zeeman_Basis"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute eigenbasis of the total Sz operator (Zeeman basis).</p>
<section id="id41">
<h4>Returns<a class="headerlink" href="#id41" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>list of QunObj</dt><dd><p>Zeeman basis vectors.</p>
</dd>
<dt>list of str</dt><dd><p>Corresponding basis labels.</p>
</dd>
</dl>
</section>
</dd></dl>

</dd></dl>

</section>
</section>
<section id="coherence-filters-module">
<h2>Coherence Filters Module<a class="headerlink" href="#coherence-filters-module" title="Link to this heading"></a></h2>
<section id="coherencefilters">
<h3><code class="xref py py-mod docutils literal notranslate"><span class="pre">CoherenceFilters</span></code><a class="headerlink" href="#coherencefilters" title="Link to this heading"></a></h3>
<p>PyOR - Python On Resonance</p>
<p>Author: Vineeth Francis Thalakottoor Jose Chacko</p>
<p>Email: <a class="reference external" href="mailto:vineethfrancis&#46;physics&#37;&#52;&#48;gmail&#46;com">vineethfrancis<span>&#46;</span>physics<span>&#64;</span>gmail<span>&#46;</span>com</a></p>
<dl class="simple">
<dt>Description:</dt><dd><p>This file contains the class <cite>CoherenceFilter</cite>.</p>
</dd>
</dl>
<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">CoherenceFilter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">class_QS</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_CoherenceFilters.html#CoherenceFilter"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Filter_Coherence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Allow_Coh</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_CoherenceFilters.html#CoherenceFilter.Filter_Coherence"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Filter to allow only selected coherence order.
Operates on the density matrix in the Zeeman basis.</p>
<section id="id42">
<h4>Parameters<a class="headerlink" href="#id42" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>rho<span class="classifier">ndarray</span></dt><dd><p>Input density matrix.</p>
</dd>
<dt>Allow_Coh<span class="classifier">int</span></dt><dd><p>The allowed coherence order to retain.</p>
</dd>
</dl>
</section>
<section id="id43">
<h4>Returns<a class="headerlink" href="#id43" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>tuple (coherence_mask, filtered_rho)</dt><dd><p>The coherence mask array and filtered density matrix.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Filter_T00</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_CoherenceFilters.html#CoherenceFilter.Filter_T00"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>T00 Filter: Extracts zero quantum coherence for selected spins.
Works on the density matrix in the Zeeman basis.</p>
<section id="id44">
<h4>Parameters<a class="headerlink" href="#id44" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>rho<span class="classifier">ndarray</span></dt><dd><p>Input density matrix.</p>
</dd>
<dt>index<span class="classifier">list or tuple of int</span></dt><dd><p>Indices of the two spins to apply the filter on.</p>
</dd>
</dl>
</section>
<section id="id45">
<h4>Returns<a class="headerlink" href="#id45" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>tuple (Filter_T00, filtered_rho)</dt><dd><p>Filter matrix and the filtered density matrix.</p>
</dd>
</dl>
</section>
</dd></dl>

</dd></dl>

</section>
</section>
<section id="commutators-module">
<h2>Commutators Module<a class="headerlink" href="#commutators-module" title="Link to this heading"></a></h2>
<section id="commutators">
<h3><code class="xref py py-mod docutils literal notranslate"><span class="pre">Commutators</span></code><a class="headerlink" href="#commutators" title="Link to this heading"></a></h3>
<p>PyOR - Python On Resonance</p>
<p>Author: Vineeth Francis Thalakottoor Jose Chacko</p>
<p>Email: <a class="reference external" href="mailto:vineethfrancis&#46;physics&#37;&#52;&#48;gmail&#46;com">vineethfrancis<span>&#46;</span>physics<span>&#64;</span>gmail<span>&#46;</span>com</a></p>
<dl class="simple">
<dt>Description:</dt><dd><p>This file contains the class <cite>Commutators</cite>.</p>
</dd>
</dl>
<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Commutators</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">class_QS</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Commutators.html#Commutators"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AntiCommutationSuperoperator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">XQ</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Commutators.html#Commutators.AntiCommutationSuperoperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Construct the anti-commutation superoperator {X, •}.</p>
<section id="id46">
<h4>Parameters<a class="headerlink" href="#id46" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>XQ<span class="classifier">ndarray or object with .data</span></dt><dd><p>Operator matrix.</p>
</dd>
</dl>
</section>
<section id="id47">
<h4>Returns<a class="headerlink" href="#id47" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>ndarray or sparse matrix</dt><dd><p>Superoperator matrix.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AntiCommutator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">AQ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">BQ</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Commutators.html#Commutators.AntiCommutator"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute the anti-commutator {A, B}.</p>
<section id="id48">
<h4>Parameters<a class="headerlink" href="#id48" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>AQ, BQ<span class="classifier">ndarray or object with .data</span></dt><dd><p>Input matrices.</p>
</dd>
</dl>
</section>
<section id="id49">
<h4>Returns<a class="headerlink" href="#id49" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>ndarray</dt><dd><p>Anti-commutator {A, B} = AB + BA</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CommutationSuperoperator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">XQ</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Commutators.html#Commutators.CommutationSuperoperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Construct the commutation superoperator [X, •].</p>
<section id="id50">
<h4>Parameters<a class="headerlink" href="#id50" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>XQ<span class="classifier">ndarray or object with .data</span></dt><dd><p>Operator matrix.</p>
</dd>
</dl>
</section>
<section id="id51">
<h4>Returns<a class="headerlink" href="#id51" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>ndarray or sparse matrix</dt><dd><p>Superoperator matrix.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Commutator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">AQ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">BQ</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Commutators.html#Commutators.Commutator"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute the commutator [A, B].</p>
<section id="id52">
<h4>Parameters<a class="headerlink" href="#id52" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>AQ, BQ<span class="classifier">ndarray or object with .data</span></dt><dd><p>Input matrices.</p>
</dd>
</dl>
</section>
<section id="id53">
<h4>Returns<a class="headerlink" href="#id53" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>ndarray</dt><dd><p>Commutator [A, B] = AB - BA</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DoubleCommutationSuperoperator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">XQ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">YQ</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Commutators.html#Commutators.DoubleCommutationSuperoperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Construct the double commutation superoperator: [X, [Y, •]].</p>
<section id="id54">
<h4>Parameters<a class="headerlink" href="#id54" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>XQ, YQ<span class="classifier">ndarray or object with .data</span></dt><dd><p>Operator matrices.</p>
</dd>
</dl>
</section>
<section id="id55">
<h4>Returns<a class="headerlink" href="#id55" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>ndarray or sparse matrix</dt><dd><p>Superoperator representing [X, [Y, ρ]].</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DoubleCommutator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">AQ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">BQ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rhoQ</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Commutators.html#Commutators.DoubleCommutator"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute the double commutator [A, [B, ρ]].</p>
<section id="id56">
<h4>Parameters<a class="headerlink" href="#id56" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>AQ, BQ, rhoQ<span class="classifier">ndarray or object with .data</span></dt><dd><p>Input matrices.</p>
</dd>
</dl>
</section>
<section id="id57">
<h4>Returns<a class="headerlink" href="#id57" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>ndarray</dt><dd><p>Double commutator result.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Left_Superoperator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">XQ</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Commutators.html#Commutators.Left_Superoperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Construct the left multiplication superoperator: X ⊗ I or I ⊗ X.</p>
<section id="id58">
<h4>Parameters<a class="headerlink" href="#id58" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>XQ<span class="classifier">ndarray or object with .data</span></dt><dd><p>Operator matrix.</p>
</dd>
</dl>
</section>
<section id="id59">
<h4>Returns<a class="headerlink" href="#id59" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>ndarray or sparse matrix</dt><dd><p>Left superoperator matrix.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Right_Superoperator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">XQ</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Commutators.html#Commutators.Right_Superoperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Construct the right multiplication superoperator: I ⊗ Xᵀ or Xᵀ ⊗ I.</p>
<section id="id60">
<h4>Parameters<a class="headerlink" href="#id60" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>XQ<span class="classifier">ndarray or object with .data</span></dt><dd><p>Operator matrix.</p>
</dd>
</dl>
</section>
<section id="id61">
<h4>Returns<a class="headerlink" href="#id61" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>ndarray or sparse matrix</dt><dd><p>Right superoperator matrix.</p>
</dd>
</dl>
</section>
</dd></dl>

</dd></dl>

</section>
</section>
<section id="crystal-orientation-module">
<h2>Crystal Orientation Module<a class="headerlink" href="#crystal-orientation-module" title="Link to this heading"></a></h2>
<section id="crystalorientation">
<h3><code class="xref py py-mod docutils literal notranslate"><span class="pre">CrystalOrientation</span></code><a class="headerlink" href="#crystalorientation" title="Link to this heading"></a></h3>
<p>PyOR - Python On Resonance</p>
<dl>
<dt>Author:</dt><dd><p>Vineeth Francis Thalakottoor Jose Chacko</p>
</dd>
<dt>Email:</dt><dd><p><a class="reference external" href="mailto:vineethfrancis&#46;physics&#37;&#52;&#48;gmail&#46;com">vineethfrancis<span>&#46;</span>physics<span>&#64;</span>gmail<span>&#46;</span>com</a></p>
</dd>
<dt>Description:</dt><dd><p>This file contains functions to load crystal orientation data.</p>
<p>It includes utilities to load data from SIMPSON-formatted CSV files and
extracted crystallite arrays from SIMPSON’s crystallite library:
<a class="reference external" href="https://github.com/vosegaard/simpson/blob/master/crystdat.c">https://github.com/vosegaard/simpson/blob/master/crystdat.c</a></p>
<p>Each function returns Euler angles alpha, beta, and the associated crystallite weights.
Gamma is assumed to be 0 and excluded unless explicitly required.</p>
</dd>
</dl>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Extract_CrystArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">array_name</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_CrystalOrientation.html#Extract_CrystArray"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Extracts crystallite alpha, beta, and weight values from a C file containing SIMPSON crystallite arrays,
and saves them to a CSV file.</p>
<section id="id62">
<h4>Parameters<a class="headerlink" href="#id62" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>file_path<span class="classifier">str</span></dt><dd><p>Path to the .c file (crystdat.c).
(Donwload from crystdat.c file from <a class="reference external" href="https://github.com/vosegaard/simpson/blob/master/crystdat.c">https://github.com/vosegaard/simpson/blob/master/crystdat.c</a>)</p>
</dd>
<dt>array_name<span class="classifier">str</span></dt><dd><p>Name of the crystallite array to extract (e.g., ‘rep2000_cryst’).</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Load_Crystallite_CSV</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filepath</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delimiter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">','</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">skiprows</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_CrystalOrientation.html#Load_Crystallite_CSV"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Loads crystallite orientation data from a SIMPSON-style CSV file.</p>
<section id="id63">
<h4>Parameters<a class="headerlink" href="#id63" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>filepath<span class="classifier">str</span></dt><dd><p>Path to the CSV file.</p>
</dd>
<dt>delimiter<span class="classifier">str, optional</span></dt><dd><p>Delimiter used in the file (default is comma).</p>
</dd>
<dt>skiprows<span class="classifier">int, optional</span></dt><dd><p>Number of rows to skip (default is 1 for header).</p>
</dd>
</dl>
</section>
<section id="id64">
<h4>Returns<a class="headerlink" href="#id64" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>alpha<span class="classifier">np.ndarray</span></dt><dd><p>Alpha Euler angles (degrees).</p>
</dd>
<dt>beta<span class="classifier">np.ndarray</span></dt><dd><p>Beta Euler angles (degrees).</p>
</dd>
<dt>gamma<span class="classifier">np.ndarray</span></dt><dd><p>Gamma Euler angles (all zeros, degrees).</p>
</dd>
<dt>weight<span class="classifier">np.ndarray</span></dt><dd><p>Solid angle weights (sum should be ~1).</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Load_rep2000</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_path</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_CrystalOrientation.html#Load_rep2000"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Load rep2000_cryst from crystdat.c and save to rep2000_cryst.csv</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Load_zcw28656</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_path</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_CrystalOrientation.html#Load_zcw28656"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Load zcw28656_cryst from crystdat.c and save to zcw28656_cryst.csv</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Load_zcw4180</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_path</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_CrystalOrientation.html#Load_zcw4180"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Load zcw4180_cryst from crystdat.c and save to zcw4180_cryst.csv</p>
</dd></dl>

</section>
</section>
<section id="density-matrix-module">
<h2>Density Matrix Module<a class="headerlink" href="#density-matrix-module" title="Link to this heading"></a></h2>
<section id="densitymatrix">
<h3><code class="xref py py-mod docutils literal notranslate"><span class="pre">DensityMatrix</span></code><a class="headerlink" href="#densitymatrix" title="Link to this heading"></a></h3>
<p>PyOR - Python On Resonance</p>
<dl>
<dt>Author:</dt><dd><p>Vineeth Francis Thalakottoor Jose Chacko</p>
</dd>
<dt>Email:</dt><dd><p><a class="reference external" href="mailto:vineethfrancis&#46;physics&#37;&#52;&#48;gmail&#46;com">vineethfrancis<span>&#46;</span>physics<span>&#64;</span>gmail<span>&#46;</span>com</a></p>
</dd>
<dt>Description:</dt><dd><p>This file contains the class for computing the equilibrium density matrix.</p>
<p>The equilibrium density matrix is a key concept in magnetic resonance,
representing the state of the system at thermal equilibrium.</p>
</dd>
</dl>
<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">DensityMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">class_QS</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">class_HAM</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_DensityMatrix.html#DensityMatrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Adjoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_DensityMatrix.html#DensityMatrix.Adjoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Return the Hermitian adjoint (conjugate transpose) of a matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Create_DensityMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_DensityMatrix.html#DensityMatrix.Create_DensityMatrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Create a density matrix from a pure state.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DensityMatrix_Components</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">AQ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dic</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rhoQ</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_DensityMatrix.html#DensityMatrix.DensityMatrix_Components"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Decompose density matrix into basis components.</p>
<section id="id65">
<h4>Parameters<a class="headerlink" href="#id65" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>AQ<span class="classifier">list of QunObj</span></dt><dd><p>Basis operator objects.</p>
</dd>
<dt>dic<span class="classifier">dict</span></dt><dd><p>Dictionary of basis labels.</p>
</dd>
<dt>rhoQ<span class="classifier">QunObj</span></dt><dd><p>Density matrix.</p>
</dd>
</dl>
</section>
<section id="id66">
<h4>Returns<a class="headerlink" href="#id66" title="Link to this heading"></a></h4>
<p>None</p>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Detection_L</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_DensityMatrix.html#DensityMatrix.Detection_L"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Detection vector for Liouville space.</p>
<section id="id67">
<h4>Parameters<a class="headerlink" href="#id67" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>X<span class="classifier">ndarray</span></dt><dd><p>Operator matrix.</p>
</dd>
</dl>
</section>
<section id="id68">
<h4>Returns<a class="headerlink" href="#id68" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>ndarray</dt><dd><p>Row vector (bra) for detection.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">EquilibriumDensityMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Ti</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">HT_approx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_DensityMatrix.html#DensityMatrix.EquilibriumDensityMatrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Calculate equilibrium density matrix for given spin temperatures.</p>
<section id="id69">
<h4>Parameters<a class="headerlink" href="#id69" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>Ti<span class="classifier">list or ndarray</span></dt><dd><p>Spin temperatures for each spin.</p>
</dd>
<dt>HT_approx<span class="classifier">bool, optional</span></dt><dd><p>Use high temperature approximation if True.</p>
</dd>
</dl>
</section>
<section id="id70">
<h4>Returns<a class="headerlink" href="#id70" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>QunObj</dt><dd><p>Equilibrium density matrix.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">EquilibriumDensityMatrix_Add_TotalHamiltonian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">HQ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">HT_approx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_DensityMatrix.html#DensityMatrix.EquilibriumDensityMatrix_Add_TotalHamiltonian"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Calculate equilibrium density matrix for total Hamiltonian.</p>
<section id="id71">
<h4>Parameters<a class="headerlink" href="#id71" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>HQ<span class="classifier">QunObj</span></dt><dd><p>Total Hamiltonian.</p>
</dd>
<dt>T<span class="classifier">float</span></dt><dd><p>Uniform spin temperature.</p>
</dd>
<dt>HT_approx<span class="classifier">bool, optional</span></dt><dd><p>Use high temperature approximation if True.</p>
</dd>
</dl>
</section>
<section id="id72">
<h4>Returns<a class="headerlink" href="#id72" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>QunObj</dt><dd><p>Equilibrium density matrix.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">FinalDensityMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">HT_approx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_DensityMatrix.html#DensityMatrix.FinalDensityMatrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Wrapper for equilibrium density matrix using final temperatures.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InitialDensityMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">HT_approx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_DensityMatrix.html#DensityMatrix.InitialDensityMatrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Wrapper for equilibrium density matrix using initial temperatures.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InnerProduct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_DensityMatrix.html#DensityMatrix.InnerProduct"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute the inner product ⟨A|B⟩.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Liouville_Bracket</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">C</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_DensityMatrix.html#DensityMatrix.Liouville_Bracket"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute the Liouville bracket ⟨A|B|C⟩.</p>
<section id="id73">
<h4>Parameters<a class="headerlink" href="#id73" title="Link to this heading"></a></h4>
<p>A, B, C : ndarrays</p>
</section>
<section id="id74">
<h4>Returns<a class="headerlink" href="#id74" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>float</dt><dd><p>Real part of the bracket.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Matrix_Round</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">roundto</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_DensityMatrix.html#DensityMatrix.Matrix_Round"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Round matrix elements to specified number of decimal places.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Matrix_Tol</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_DensityMatrix.html#DensityMatrix.Matrix_Tol"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Zero out small values in a matrix below tolerance.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Norm_Matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_DensityMatrix.html#DensityMatrix.Norm_Matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute the Frobenius norm of a matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Normalize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_DensityMatrix.html#DensityMatrix.Normalize"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Return a normalized operator with unit inner product.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PolarizationVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">spinQ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rhoQ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">SzQ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">PolPercentage</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_DensityMatrix.html#DensityMatrix.PolarizationVector"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute polarization of a spin system.</p>
<section id="id75">
<h4>Parameters<a class="headerlink" href="#id75" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>spinQ<span class="classifier">float</span></dt><dd><p>Spin quantum number.</p>
</dd>
<dt>rhoQ<span class="classifier">QunObj</span></dt><dd><p>Density matrix.</p>
</dd>
<dt>SzQ<span class="classifier">QunObj</span></dt><dd><p>Spin-z operator.</p>
</dd>
<dt>PolPercentage<span class="classifier">bool</span></dt><dd><p>Return value as percentage if True.</p>
</dd>
</dl>
</section>
<section id="id76">
<h4>Returns<a class="headerlink" href="#id76" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>float</dt><dd><p>Spin polarization value.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ProductOperators_ConvertToLiouville</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Basis_X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_DensityMatrix.html#DensityMatrix.ProductOperators_ConvertToLiouville"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Convert basis operators to Liouville space.</p>
<section id="id77">
<h4>Parameters<a class="headerlink" href="#id77" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>Basis_X<span class="classifier">list of ndarrays</span></dt><dd><p>Basis operators in Hilbert space.</p>
</dd>
</dl>
</section>
<section id="id78">
<h4>Returns<a class="headerlink" href="#id78" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>list of QunObj</dt><dd><p>Operators in Liouville space.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Update</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_DensityMatrix.html#DensityMatrix.Update"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Update matrix tolerance from quantum system settings.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Vector_L</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_DensityMatrix.html#DensityMatrix.Vector_L"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Vectorize an operator into a Liouville space column vector.</p>
<section id="id79">
<h4>Parameters<a class="headerlink" href="#id79" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>X<span class="classifier">ndarray</span></dt><dd><p>Operator matrix.</p>
</dd>
</dl>
</section>
<section id="id80">
<h4>Returns<a class="headerlink" href="#id80" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>ndarray</dt><dd><p>Vectorized form.</p>
</dd>
</dl>
</section>
</dd></dl>

</dd></dl>

</section>
</section>
<section id="evolution-module">
<h2>Evolution Module<a class="headerlink" href="#evolution-module" title="Link to this heading"></a></h2>
<section id="evolution">
<h3><code class="xref py py-mod docutils literal notranslate"><span class="pre">Evolution</span></code><a class="headerlink" href="#evolution" title="Link to this heading"></a></h3>
<p>PyOR - Python On Resonance</p>
<dl class="simple">
<dt>Author:</dt><dd><p>Vineeth Francis Thalakottoor Jose Chacko</p>
</dd>
<dt>Email:</dt><dd><p><a class="reference external" href="mailto:vineethfrancis&#46;physics&#37;&#52;&#48;gmail&#46;com">vineethfrancis<span>&#46;</span>physics<span>&#64;</span>gmail<span>&#46;</span>com</a></p>
</dd>
<dt>Description:</dt><dd><p>This file contains the class <cite>Evolutions</cite>, which is used for simulating 
time evolution of spin systems under different Hamiltonians and conditions.</p>
</dd>
</dl>
<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Evolutions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">class_QS</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">class_Ham</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Evolution.html#Evolutions"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Commutator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Evolution.html#Evolutions.Commutator"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><section id="input">
<h4>INPUT<a class="headerlink" href="#input" title="Link to this heading"></a></h4>
<p>A : matrix A
B : matrix B</p>
</section>
<section id="output">
<h4>OUTPUT<a class="headerlink" href="#output" title="Link to this heading"></a></h4>
<p>Commutator [A,B]</p>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Convert_LrhoTO2Drho</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Lrho</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Evolution.html#Evolutions.Convert_LrhoTO2Drho"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Convert a Vector into a 2d Matrix</p>
<section id="id81">
<h4>INPUT<a class="headerlink" href="#id81" title="Link to this heading"></a></h4>
<p>Lrho: density matrix, coloumn vector
OUTPUT
——        
return density matrix, 2d array</p>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Evolution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rhoQ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rhoeqQ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">HamiltonianQ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">RelaxationQ</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">HamiltonianArray</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Evolution.html#Evolutions.Evolution"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Expectation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho_t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">detectionQ</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Evolution.html#Evolutions.Expectation"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TimeDependent_Hamiltonian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Evolution.html#Evolutions.TimeDependent_Hamiltonian"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TimeDependent_Hamiltonian_Hilbert</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Evolution.html#Evolutions.TimeDependent_Hamiltonian_Hilbert"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Update</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Evolution.html#Evolutions.Update"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd></dd></dl>

</dd></dl>

</section>
</section>
<section id="fitting-module">
<h2>Fitting Module<a class="headerlink" href="#fitting-module" title="Link to this heading"></a></h2>
<section id="fitting">
<h3><code class="xref py py-mod docutils literal notranslate"><span class="pre">Fitting</span></code><a class="headerlink" href="#fitting" title="Link to this heading"></a></h3>
<p>PyOR - Python On Resonance</p>
<dl>
<dt>Author:</dt><dd><p>Vineeth Francis Thalakottoor Jose Chacko</p>
</dd>
<dt>Email:</dt><dd><p><a class="reference external" href="mailto:vineethfrancis&#46;physics&#37;&#52;&#48;gmail&#46;com">vineethfrancis<span>&#46;</span>physics<span>&#64;</span>gmail<span>&#46;</span>com</a></p>
</dd>
<dt>Description:</dt><dd><p>This file contains functions for curve fitting, typically used to 
analyze simulation outputs and extract physical parameters.</p>
<p>Functions include utilities for fitting decay curves, frequency 
sweeps, and relaxation models relevant to magnetic resonance experiments.</p>
</dd>
</dl>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Exp_Buildup</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Fitting.html#Exp_Buildup"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Exponential build-up function.</p>
<section id="model">
<h4>Model<a class="headerlink" href="#model" title="Link to this heading"></a></h4>
<p>f(x) = c - (c - a) * exp(-b * x)</p>
</section>
<section id="id82">
<h4>Parameters<a class="headerlink" href="#id82" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>x<span class="classifier">array_like</span></dt><dd><p>Independent variable.</p>
</dd>
<dt>a, b, c<span class="classifier">float</span></dt><dd><p>Fit parameters.</p>
</dd>
</dl>
</section>
<section id="id83">
<h4>Returns<a class="headerlink" href="#id83" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>array_like</dt><dd><p>Evaluated function.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Exp_Decay</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Fitting.html#Exp_Decay"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Single exponential decay function.</p>
<section id="id84">
<h4>Model<a class="headerlink" href="#id84" title="Link to this heading"></a></h4>
<p>f(x) = a * exp(-b * x) + c</p>
</section>
<section id="id85">
<h4>Parameters<a class="headerlink" href="#id85" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>x<span class="classifier">array_like</span></dt><dd><p>Independent variable.</p>
</dd>
<dt>a, b, c<span class="classifier">float</span></dt><dd><p>Fit parameters.</p>
</dd>
</dl>
</section>
<section id="id86">
<h4>Returns<a class="headerlink" href="#id86" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>array_like</dt><dd><p>Evaluated function.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Exp_Decay_2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">e</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Fitting.html#Exp_Decay_2"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Double exponential decay function.</p>
<section id="id87">
<h4>Model<a class="headerlink" href="#id87" title="Link to this heading"></a></h4>
<p>f(x) = a * exp(-b * x) + c * exp(-d * x) + e</p>
</section>
<section id="id88">
<h4>Parameters<a class="headerlink" href="#id88" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>x<span class="classifier">array_like</span></dt><dd><p>Independent variable.</p>
</dd>
<dt>a, b, c, d, e<span class="classifier">float</span></dt><dd><p>Fit parameters.</p>
</dd>
</dl>
</section>
<section id="id89">
<h4>Returns<a class="headerlink" href="#id89" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>array_like</dt><dd><p>Evaluated function.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Fitting_LeastSquare</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xdata</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ydata</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Fitting.html#Fitting_LeastSquare"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Perform non-linear least squares fitting using a custom function.</p>
<section id="id90">
<h4>Parameters<a class="headerlink" href="#id90" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>func<span class="classifier">callable</span></dt><dd><p>Model function to fit, with signature <cite>func(x, …)</cite>.</p>
</dd>
<dt>xdata<span class="classifier">array_like</span></dt><dd><p>Independent data (x-values).</p>
</dd>
<dt>ydata<span class="classifier">array_like</span></dt><dd><p>Dependent data (y-values).</p>
</dd>
</dl>
</section>
<section id="id91">
<h4>Returns<a class="headerlink" href="#id91" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>popt<span class="classifier">array</span></dt><dd><p>Optimal values for the parameters.</p>
</dd>
<dt>pcov<span class="classifier">2D array</span></dt><dd><p>Estimated covariance of popt.</p>
</dd>
</dl>
</section>
<section id="id92">
<h4>Notes<a class="headerlink" href="#id92" title="Link to this heading"></a></h4>
<p>For more details, see:
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.curve_fit.html">https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.curve_fit.html</a></p>
</section>
</dd></dl>

</section>
</section>
<section id="gamma-module">
<h2>Gamma Module<a class="headerlink" href="#gamma-module" title="Link to this heading"></a></h2>
<section id="gamma">
<h3><code class="xref py py-mod docutils literal notranslate"><span class="pre">Gamma</span></code><a class="headerlink" href="#gamma" title="Link to this heading"></a></h3>
<p>PyOR - Python On Resonance</p>
<dl class="simple">
<dt>Author:</dt><dd><p>Vineeth Francis Thalakottoor Jose Chacko</p>
</dd>
<dt>Email:</dt><dd><p><a class="reference external" href="mailto:vineethfrancis&#46;physics&#37;&#52;&#48;gmail&#46;com">vineethfrancis<span>&#46;</span>physics<span>&#64;</span>gmail<span>&#46;</span>com</a></p>
</dd>
<dt>Description:</dt><dd><p>This file contains the gyromagnetic ratios of the electron and various nuclei
commonly encountered in magnetic resonance experiments.</p>
</dd>
</dl>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">gamma</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Gamma.html#gamma"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Returns the gyromagnetic ratio (γ) of a specified particle.</p>
<p>The gyromagnetic ratio is a fundamental physical constant that relates the 
magnetic moment of a particle to its angular momentum. It plays a key role 
in nuclear magnetic resonance (NMR), electron paramagnetic resonance (EPR), 
and magnetic field interactions.</p>
<section id="id93">
<h4>Parameters:<a class="headerlink" href="#id93" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>value<span class="classifier">str</span></dt><dd><dl class="simple">
<dt>Symbol representing the particle. Common examples include:</dt><dd><ul class="simple">
<li><p>“E”   : Electron</p></li>
<li><p>“H1”  : Proton (Hydrogen-1)</p></li>
<li><p>“H2”  : Deuterium (Hydrogen-2)</p></li>
<li><p>“C13” : Carbon-13</p></li>
<li><p>“N14” : Nitrogen-14</p></li>
<li><p>“N15” : Nitrogen-15</p></li>
<li><p>“O17” : Oxygen-17</p></li>
<li><p>“F19” : Fluorine-19</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
</section>
<section id="id94">
<h4>Returns:<a class="headerlink" href="#id94" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>float</dt><dd><p>Gyromagnetic ratio of the given particle, in units of radians per second per tesla (rad·s⁻¹·T⁻¹).</p>
</dd>
</dl>
</section>
<section id="raises">
<h4>Raises:<a class="headerlink" href="#raises" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>AssertionError</dt><dd><p>If the particle symbol is not found in the predefined <cite>GAMMA</cite> dictionary.
In such cases, users are expected to define and add the gyromagnetic ratio manually.</p>
</dd>
</dl>
</section>
<section id="example">
<h4>Example:<a class="headerlink" href="#example" title="Link to this heading"></a></h4>
<p>gamma(“H1”)
267522000.0</p>
<p>gamma(“N15”)
-27116000.0</p>
</section>
<section id="id95">
<h4>Reference:<a class="headerlink" href="#id95" title="Link to this heading"></a></h4>
<p>Harris, R. K., Becker, E. D., de Menezes, S. M. C., Goodfellow, R., &amp; Granger, P. (2001).  
NMR nomenclature. Nuclear spin properties and conventions for chemical shifts (IUPAC Recommendations 2001).  
<em>Pure and Applied Chemistry</em>, 73(11), 1795–1818.  
DOI: <a class="reference external" href="https://doi.org/10.1351/pac200173111795">https://doi.org/10.1351/pac200173111795</a></p>
</section>
</dd></dl>

</section>
</section>
<section id="hamiltonian-module">
<h2>Hamiltonian Module<a class="headerlink" href="#hamiltonian-module" title="Link to this heading"></a></h2>
<section id="hamiltonian">
<h3><code class="xref py py-mod docutils literal notranslate"><span class="pre">Hamiltonian</span></code><a class="headerlink" href="#hamiltonian" title="Link to this heading"></a></h3>
<p>PyOR - Python On Resonance</p>
<dl>
<dt>Author:</dt><dd><p>Vineeth Francis Thalakottoor Jose Chacko</p>
</dd>
<dt>Email:</dt><dd><p><a class="reference external" href="mailto:vineethfrancis&#46;physics&#37;&#52;&#48;gmail&#46;com">vineethfrancis<span>&#46;</span>physics<span>&#64;</span>gmail<span>&#46;</span>com</a></p>
</dd>
<dt>Description:</dt><dd><p>This file contains the <cite>Hamiltonian</cite> class, which provides routines for building 
various spin interaction Hamiltonians used in magnetic resonance simulations.</p>
<p>Supported interactions may include Zeeman, dipolar coupling, scalar coupling, 
and quadrupolar interactions depending on system specifications.</p>
</dd>
</dl>
<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Hamiltonian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">class_QS</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Hamiltonian.html#Hamiltonian"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DDcoupling</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Hamiltonian.html#Hamiltonian.DDcoupling"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Construct the Dipole-Dipole (DD) interaction Hamiltonian for all spin pairs.</p>
<p>Supports:
- Secular approximation (Hetero &amp; Homo)
- Full interaction (All terms: secular, pseudo-secular, non-secular)
- Individual components: A, B, C, D, E, F</p>
<section id="inputs-from-class-qs">
<h4>Inputs from class_QS:<a class="headerlink" href="#inputs-from-class-qs" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p>DipolePairs: list of (i, j) spin index pairs</p></li>
<li><p>DipoleAngle: list of (theta, phi) for each pair in degrees</p></li>
<li><p>DipolebIS: list of dipolar coupling constants (Hz)</p></li>
<li><p>Dipole_DipolarAlpabet: interaction mode (secular, All, A–F)</p></li>
</ul>
</section>
<section id="id96">
<h4>Output:<a class="headerlink" href="#id96" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>QunObj</dt><dd><p>Complete DD coupling Hamiltonian in angular frequency units</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Dipole_Coupling_Constant</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Gamma1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Gamma2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distance</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Hamiltonian.html#Hamiltonian.Dipole_Coupling_Constant"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute the dipolar coupling constant between two spins.</p>
<p>Formula:
b_IS = - (μ₀ / 4π) * (γ₁ * γ₂ * ℏ) / r³</p>
<section id="inputs">
<h4>Inputs:<a class="headerlink" href="#inputs" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>Gamma1<span class="classifier">float</span></dt><dd><p>Gyromagnetic ratio of spin 1 (rad/T·s)</p>
</dd>
<dt>Gamma2<span class="classifier">float</span></dt><dd><p>Gyromagnetic ratio of spin 2 (rad/T·s)</p>
</dd>
<dt>distance<span class="classifier">float</span></dt><dd><p>Inter-spin distance in meters</p>
</dd>
</dl>
</section>
<section id="id97">
<h4>Output:<a class="headerlink" href="#id97" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>float</dt><dd><p>Dipolar coupling constant in Hz</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Eigen</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Hamiltonian.html#Hamiltonian.Eigen"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute eigenvalues and eigenvectors of a Hamiltonian.</p>
<section id="id98">
<h4>Parameters:<a class="headerlink" href="#id98" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>H<span class="classifier">np.ndarray</span></dt><dd><p>Hamiltonian matrix</p>
</dd>
</dl>
</section>
<section id="id99">
<h4>Returns:<a class="headerlink" href="#id99" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>tuple</dt><dd><p>(eigenvalues, eigenvectors)</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InteractionTensor_LAB</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ApafQ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Hamiltonian.html#Hamiltonian.InteractionTensor_LAB"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Rotates a tensor from PAF to LAB frame using spherical tensors and Wigner rotation.</p>
<section id="id100">
<h4>Parameters:<a class="headerlink" href="#id100" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>ApafQ<span class="classifier">QunObj</span></dt><dd><p>Tensor in principal axis frame</p>
</dd>
<dt>alpha, beta, gamma<span class="classifier">float</span></dt><dd><p>Euler angles</p>
</dd>
</dl>
</section>
<section id="id101">
<h4>Returns:<a class="headerlink" href="#id101" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>QunObj</dt><dd><p>Rotated tensor in LAB frame</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InteractionTensor_LAB_Decomposition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">AQ</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Hamiltonian.html#Hamiltonian.InteractionTensor_LAB_Decomposition"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Decomposes a LAB-frame tensor into isotropic, symmetric, and antisymmetric parts.</p>
<section id="id102">
<h4>Parameters:<a class="headerlink" href="#id102" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>AQ<span class="classifier">QunObj</span></dt><dd><p>LAB-frame tensor</p>
</dd>
</dl>
</section>
<section id="id103">
<h4>Returns:<a class="headerlink" href="#id103" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>dict</dt><dd><p>Dictionary with QunObj entries:
“Isotropic”, “Symmetric”, “Antisymmetric”</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InteractionTensor_PAF_CSA</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Iso</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Aniso</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Asymmetry</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Hamiltonian.html#Hamiltonian.InteractionTensor_PAF_CSA"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Constructs the CSA interaction tensor in the principal axis frame (PAF).</p>
<section id="id104">
<h4>Parameters:<a class="headerlink" href="#id104" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>Iso<span class="classifier">float</span></dt><dd><p>Isotropic component</p>
</dd>
<dt>Aniso<span class="classifier">float</span></dt><dd><p>Anisotropy (Azz - Iso)</p>
</dd>
<dt>Asymmetry<span class="classifier">float</span></dt><dd><p>Asymmetry parameter (eta = (Ayy - Axx) / Aniso),  range from 0 &lt;= eta &lt;= 1</p>
</dd>
</dl>
</section>
<section id="id105">
<h4>Returns:<a class="headerlink" href="#id105" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>QunObj</dt><dd><p>3x3 CSA tensor in PAF</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InteractionTensor_PAF_Decomposition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">AQ</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Hamiltonian.html#Hamiltonian.InteractionTensor_PAF_Decomposition"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Decomposes a PAF tensor into isotropic, anisotropy, and asymmetry components.</p>
<section id="id106">
<h4>Parameters:<a class="headerlink" href="#id106" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>AQ<span class="classifier">QunObj</span></dt><dd><p>Tensor to decompose</p>
</dd>
</dl>
</section>
<section id="id107">
<h4>Returns:<a class="headerlink" href="#id107" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>dict</dt><dd><p>Dictionary with keys: “Isotropic”, “Anisotropy”, “Asymmetry”</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InteractionTensor_PAF_Dipole</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Hamiltonian.html#Hamiltonian.InteractionTensor_PAF_Dipole"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Constructs a PAF dipolar tensor.</p>
<section id="id108">
<h4>Parameters:<a class="headerlink" href="#id108" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>d<span class="classifier">float</span></dt><dd><p>Dipolar coupling constant (in Hz)</p>
</dd>
</dl>
</section>
<section id="id109">
<h4>Returns:<a class="headerlink" href="#id109" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>QunObj</dt><dd><p>Dipolar tensor in the PAF</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InteractionTensor_PAF_ElectronZeeman</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gshiftList</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Hamiltonian.html#Hamiltonian.InteractionTensor_PAF_ElectronZeeman"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Constructs the electron Zeeman interaction tensor in the principal axis frame (PAF).</p>
<p>This method calculates the electron Zeeman interaction tensor by combining the isotropic
contribution (from the free electron g-factor) and the anisotropic shifts (g-shifts).
If specified, the resulting tensor components are converted to angular frequency units.</p>
<section id="id110">
<h4>Parameters:<a class="headerlink" href="#id110" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>gshiftList<span class="classifier">list or array-like of float</span></dt><dd><p>A list of three g-shift values [g_xx, g_yy, g_zz] representing the anisotropic g-tensor
components in the principal axis frame.</p>
</dd>
</dl>
</section>
<section id="id111">
<h4>Returns:<a class="headerlink" href="#id111" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>QunObj</dt><dd><p>A quantum object representing the full 3x3 electron Zeeman interaction tensor.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InteractionTensor_PAF_General</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">diagList</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Hamiltonian.html#Hamiltonian.InteractionTensor_PAF_General"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Constructs an interaction tensor in the Principal Axis Frame (PAF) from a diagonal list of components.</p>
<p>This method builds a 3x3 diagonal interaction tensor in the PAF using values provided in <cite>diagList</cite>.
If the <cite>InteractioTensor_AngularFrequency</cite> flag is set to True, the input values are assumed to be in Hz
and are converted to angular frequency units (rad/s) by multiplying by 2π.</p>
<section id="id112">
<h4>Parameters<a class="headerlink" href="#id112" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>diagList<span class="classifier">list or array-like of float</span></dt><dd><p>A list or array with three diagonal elements representing the interaction tensor
components along the x, y, and z axes in the PAF. Units are Hz unless the flag
<cite>InteractioTensor_AngularFrequency</cite> is True, in which case the result will be in rad/s.</p>
</dd>
</dl>
</section>
<section id="id113">
<h4>Returns<a class="headerlink" href="#id113" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>QunObj</dt><dd><p>An instance of <cite>QunObj</cite> representing the 3x3 interaction tensor matrix constructed
from the diagonal values.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InteractionTensor_PAF_Quadrupole</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Coupling</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">etaQ</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Hamiltonian.html#Hamiltonian.InteractionTensor_PAF_Quadrupole"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Constructs the quadrupolar tensor in the PAF.</p>
<section id="id114">
<h4>Parameters:<a class="headerlink" href="#id114" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>X<span class="classifier">str</span></dt><dd><p>Spin label</p>
</dd>
<dt>eq<span class="classifier">float</span></dt><dd><p>Electric field gradient</p>
</dd>
<dt>etaQ<span class="classifier">float</span></dt><dd><p>Quadrupolar asymmetry parameter</p>
</dd>
</dl>
</section>
<section id="id115">
<h4>Returns:<a class="headerlink" href="#id115" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>QunObj</dt><dd><p>Quadrupolar tensor in the PAF</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InteractionTensor_PAF_ZeroField</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">D</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">E</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Hamiltonian.html#Hamiltonian.InteractionTensor_PAF_ZeroField"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Constructs the zero-field splitting (ZFS) interaction tensor in the principal axis frame (PAF).</p>
<p>This method builds a symmetric 3x3 tensor representing the ZFS interaction for an electron
spin system in the absence of an external magnetic field. The tensor is expressed in angular
frequency units (i.e., radians per second), assuming D and E are initially given in Hz.</p>
<section id="id116">
<h4>Parameters:<a class="headerlink" href="#id116" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>D<span class="classifier">float</span></dt><dd><p>The axial zero-field splitting parameter (in Hz).</p>
</dd>
<dt>E<span class="classifier">float</span></dt><dd><p>The rhombic zero-field splitting parameter (in Hz).</p>
</dd>
</dl>
</section>
<section id="id117">
<h4>Returns:<a class="headerlink" href="#id117" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>QunObj</dt><dd><p>A quantum object representing the 3x3 zero-field splitting interaction tensor.</p>
</dd>
</dl>
</section>
<section id="id118">
<h4>Notes:<a class="headerlink" href="#id118" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p>D and E are converted to angular frequency units by multiplying with 2π.</p></li>
<li><dl class="simple">
<dt>The tensor is constructed with the following diagonal elements:</dt><dd><ul>
<li><p>T_xx = (-1/3) * D + E</p></li>
<li><p>T_yy = (-1/3) * D - E</p></li>
<li><p>T_zz = (2/3) * D</p></li>
</ul>
</dd>
</dl>
</li>
<li><p>This is appropriate for spin systems with S &gt; 1/2, typically S = 1.</p></li>
</ul>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Interaction_Hamiltonian_Catesian_Euler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">XQ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">AQ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">YQ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Hamiltonian.html#Hamiltonian.Interaction_Hamiltonian_Catesian_Euler"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Rotate interaction tensor using Euler angles and construct Hamiltonian in Cartesian space.</p>
<section id="id119">
<h4>Parameters:<a class="headerlink" href="#id119" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>XQ<span class="classifier">str</span></dt><dd><p>Name of spin operator (e.g., “I”)</p>
</dd>
<dt>AQ<span class="classifier">QunObj</span></dt><dd><p>Interaction tensor in PAF</p>
</dd>
<dt>YQ<span class="classifier">str</span></dt><dd><p>Second spin operator (e.g., “S”), or “” if external field</p>
</dd>
<dt>alpha, beta, gamma<span class="classifier">float</span></dt><dd><p>Euler angles in radians</p>
</dd>
</dl>
</section>
<section id="id120">
<h4>Returns:<a class="headerlink" href="#id120" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>QunObj</dt><dd><p>The interaction Hamiltonian</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Interaction_Hamiltonian_Catesian_Wigner</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">XQ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ApafQ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">YQ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Hamiltonian.html#Hamiltonian.Interaction_Hamiltonian_Catesian_Wigner"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>General interaction Hamiltonian using Wigner rotation of Cartesian tensors.</p>
<section id="id121">
<h4>Parameters:<a class="headerlink" href="#id121" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>XQ<span class="classifier">str</span></dt><dd><p>Name of the spin operator prefix (e.g., “I” or “S”).</p>
</dd>
<dt>ApafQ<span class="classifier">QunObj</span></dt><dd><p>Interaction tensor in PAF (Principal Axis Frame).</p>
</dd>
<dt>YQ<span class="classifier">str</span></dt><dd><p>Second spin operator prefix (e.g., “S”) or “” if interacting with external field.</p>
</dd>
<dt>alpha, beta, gamma<span class="classifier">float</span></dt><dd><p>Euler angles in radians to rotate from PAF to lab frame.</p>
</dd>
</dl>
</section>
<section id="id122">
<h4>Returns:<a class="headerlink" href="#id122" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>QunObj</dt><dd><p>The interaction Hamiltonian.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Interaction_Hamiltonian_LAB_CSA_Secular</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ApasQ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Hamiltonian.html#Hamiltonian.Interaction_Hamiltonian_LAB_CSA_Secular"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Constructs the secular CSA Hamiltonian in the lab frame.</p>
<section id="id123">
<h4>Parameters:<a class="headerlink" href="#id123" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>X<span class="classifier">str</span></dt><dd><p>Spin label (e.g., ‘I’ or ‘S’)</p>
</dd>
<dt>ApasQ<span class="classifier">QunObj</span></dt><dd><p>CSA tensor in PAF (principal axis frame)</p>
</dd>
<dt>theta<span class="classifier">float</span></dt><dd><p>Polar angle in degrees</p>
</dd>
<dt>phi<span class="classifier">float</span></dt><dd><p>Azimuthal angle in degrees</p>
</dd>
</dl>
</section>
<section id="id124">
<h4>Returns:<a class="headerlink" href="#id124" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>QunObj</dt><dd><p>The secular CSA Hamiltonian component.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Interaction_Hamiltonian_LAB_Quadrupole_Secular</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Coupling</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">etaQ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Hamiltonian.html#Hamiltonian.Interaction_Hamiltonian_LAB_Quadrupole_Secular"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Constructs the secular quadrupole Hamiltonian.</p>
<section id="id125">
<h4>Parameters:<a class="headerlink" href="#id125" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>X<span class="classifier">str</span></dt><dd><p>Nucleus label</p>
</dd>
<dt>eq<span class="classifier">float</span></dt><dd><p>Electric field gradient</p>
</dd>
<dt>etaQ<span class="classifier">float</span></dt><dd><p>Quadrupolar asymmetry parameter</p>
</dd>
<dt>theta, phi<span class="classifier">float</span></dt><dd><p>Orientation angles in degrees</p>
</dd>
</dl>
</section>
<section id="id126">
<h4>Returns:<a class="headerlink" href="#id126" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>QunObj</dt><dd><p>The quadrupole Hamiltonian</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Interaction_Hamiltonian_MAS_SphericalTensor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ApafQ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">approx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Hamiltonian.html#Hamiltonian.Interaction_Hamiltonian_MAS_SphericalTensor"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>General Hamiltonian using spherical tensor formalism for Magical Angle Spinning (MAS).</p>
<section id="id127">
<h4>Reference:<a class="headerlink" href="#id127" title="Link to this heading"></a></h4>
<p>Michael Mehring, Internal Spin Interactions and Rotations in Solids.</p>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Interaction_Hamiltonian_SphericalTensor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ApafQ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">approx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Hamiltonian.html#Hamiltonian.Interaction_Hamiltonian_SphericalTensor"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>General Hamiltonian using spherical tensor formalism.</p>
<section id="id128">
<h4>Reference:<a class="headerlink" href="#id128" title="Link to this heading"></a></h4>
<p>Michael Mehring, Internal Spin Interactions and Rotations in Solids.</p>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Jcoupling</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Hamiltonian.html#Hamiltonian.Jcoupling"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Construct full J-coupling Hamiltonian (isotropic scalar coupling).</p>
<p>H_J = ∑₍i&lt;j₎ J_ij * (Sxᵢ·Sxⱼ + Syᵢ·Syⱼ + Szᵢ·Szⱼ)</p>
<section id="id129">
<h4>Inputs:<a class="headerlink" href="#id129" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>J<span class="classifier">2D array (Hz)</span></dt><dd><p>Symmetric matrix of J-couplings between spins i and j.</p>
</dd>
<dt>Sx, Sy, Sz<span class="classifier">list of ndarray</span></dt><dd><p>Cartesian spin operators for all spins.</p>
</dd>
</dl>
</section>
<section id="id130">
<h4>Output:<a class="headerlink" href="#id130" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>QunObj</dt><dd><p>Full J-coupling Hamiltonian (angular frequency units).</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Jcoupling_Weak</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Hamiltonian.html#Hamiltonian.Jcoupling_Weak"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Construct simplified J-coupling Hamiltonian (weak coupling approximation).</p>
<p>H_J ≈ ∑₍i&lt;j₎ J_ij * Szᵢ·Szⱼ</p>
<section id="id131">
<h4>Inputs:<a class="headerlink" href="#id131" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>J<span class="classifier">2D array (Hz)</span></dt><dd><p>Symmetric matrix of J-couplings between spins i and j.</p>
</dd>
<dt>Sz<span class="classifier">list of ndarray</span></dt><dd><p>Z-component spin operators.</p>
</dd>
</dl>
</section>
<section id="id132">
<h4>Output:<a class="headerlink" href="#id132" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>QunObj</dt><dd><p>Simplified J-coupling Hamiltonian (angular frequency units).</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LarmorFrequency</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Hamiltonian.html#Hamiltonian.LarmorFrequency"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Computes the Larmor frequency (Ω₀) for each spin in the lab frame.</p>
<dl class="simple">
<dt>Larmor frequency is given by:</dt><dd><p>Ω₀ = -γ * B₀ - 2π * δ</p>
</dd>
<dt>where:</dt><dd><p>γ = gyromagnetic ratio,
B₀ = magnetic field strength in Tesla,
δ = chemical shift offset (in Hz)</p>
</dd>
</dl>
<section id="id133">
<h4>Returns:<a class="headerlink" href="#id133" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>numpy.ndarray</dt><dd><p>Larmor frequencies (angular frequencies) for each spin in the system.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MASSpectrum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">EVol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rhoI</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rhoeq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">IT_PAF</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">approx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weighted</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">MagicAngle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">RotortFrequency</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ncores</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">apodization</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Hamiltonian.html#Hamiltonian.MASSpectrum"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Computes the Magic Angle Spinning (MAS) powder-averaged spectrum.</p>
<p>This function constructs a periodic time-dependent Hamiltonian array for MAS,
evolving the system under that Hamiltonian, and computing the spectrum by Fourier transforming
the expectation values.</p>
<section id="id134">
<h4>Parameters:<a class="headerlink" href="#id134" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>EVol<span class="classifier">Evolution object</span></dt><dd><p>Evolution class instance capable of time evolution.</p>
</dd>
<dt>rhoI<span class="classifier">ndarray</span></dt><dd><p>Initial density matrix.</p>
</dd>
<dt>rhoeq<span class="classifier">ndarray</span></dt><dd><p>Equilibrium density matrix.</p>
</dd>
<dt>X<span class="classifier">str</span></dt><dd><p>Spin species (e.g., “H”, “C”).</p>
</dd>
<dt>IT_PAF<span class="classifier">ndarray</span></dt><dd><p>Interaction tensor in principal axis frame (PAF).</p>
</dd>
<dt>Y<span class="classifier">str</span></dt><dd><p>Secondary spin species for spin-spin interactions (can be empty for spin-field interactions).</p>
</dd>
<dt>string<span class="classifier">str</span></dt><dd><p>Type of interaction: “spin-field” or “spin-spin”.</p>
</dd>
<dt>approx<span class="classifier">str</span></dt><dd><p>Approximation method: “all”, “secular”, or “secular + pseudosecular”.</p>
</dd>
<dt>alpha, beta, gamma<span class="classifier">array-like</span></dt><dd><p>Orientation angles (in radians) for the powder averaging.</p>
</dd>
<dt>weighted<span class="classifier">bool, optional</span></dt><dd><p>Whether to use weighted averaging. Default is True.</p>
</dd>
<dt>weight<span class="classifier">ndarray, optional</span></dt><dd><p>Weights for each crystallite orientation.</p>
</dd>
<dt>MagicAngle<span class="classifier">float, optional</span></dt><dd><p>Magic angle value in degrees. Default is 0.</p>
</dd>
<dt>RotortFrequency<span class="classifier">float, optional</span></dt><dd><p>Spinning frequency in Hz. Default is 0.</p>
</dd>
<dt>ncores<span class="classifier">int, optional</span></dt><dd><p>Number of cores for parallelization. Default is -2 (use all but two cores).</p>
</dd>
<dt>apodization<span class="classifier">float, optional</span></dt><dd><p>Apodization factor for windowing. Default is 0.</p>
</dd>
</dl>
</section>
<section id="id135">
<h4>Returns:<a class="headerlink" href="#id135" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>freq<span class="classifier">ndarray</span></dt><dd><p>Frequency axis (Hz).</p>
</dd>
<dt>spectrum<span class="classifier">ndarray</span></dt><dd><p>Powder-averaged spectrum (absolute value).</p>
</dd>
</dl>
</section>
<section id="acknowledgements">
<h4>Acknowledgements:<a class="headerlink" href="#acknowledgements" title="Link to this heading"></a></h4>
<ol class="arabic simple">
<li><p>Subhadip Pradhan, TIFR Hyderabad, for sharing the concept of using periodic Hamiltonian.</p></li>
</ol>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MASSpectrum2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">EVol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rhoI</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rhoeq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">IT_PAF</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">approx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weighted</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">MagicAngle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">RotortFrequency</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ncores</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">apodization</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Hamiltonian.html#Hamiltonian.MASSpectrum2"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>&lt;&lt;&lt;&lt; Attention: This function is slow. &gt;&gt;&gt;&gt;</p>
<p>Computes the powder-averaged spectrum over (alpha, beta, gamma) angles.</p>
<section id="id136">
<h4>Parameters:<a class="headerlink" href="#id136" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>weighted<span class="classifier">bool</span></dt><dd><p>Whether to use weighted averaging.</p>
</dd>
<dt>weight<span class="classifier">ndarray or None</span></dt><dd><p>Optional crystallite weights. If None and weighted=True,
defaults to sin(beta) weighting.</p>
</dd>
</dl>
</section>
<section id="id137">
<h4>Returns:<a class="headerlink" href="#id137" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>freq<span class="classifier">ndarray</span></dt><dd><p>Frequency axis.</p>
</dd>
<dt>spectrum<span class="classifier">ndarray</span></dt><dd><p>Powder-averaged spectrum (absolute value).</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PowderSpectrum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">EVol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rhoI</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rhoeq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">IT_PAF</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">approx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weighted</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">SecularEquation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'spherical'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ncores</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">apodization</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Hamiltonian.html#Hamiltonian.PowderSpectrum"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Computes the powder-averaged spectrum over (alpha, beta, gamma) angles.</p>
<section id="id138">
<h4>Parameters:<a class="headerlink" href="#id138" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>weighted<span class="classifier">bool</span></dt><dd><p>Whether to use weighted averaging.</p>
</dd>
<dt>weight<span class="classifier">ndarray or None</span></dt><dd><p>Optional crystallite weights. If None and weighted=True,
defaults to sin(beta) weighting.</p>
</dd>
</dl>
</section>
<section id="id139">
<h4>Returns:<a class="headerlink" href="#id139" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>freq<span class="classifier">ndarray</span></dt><dd><p>Frequency axis.</p>
</dd>
<dt>spectrum<span class="classifier">ndarray</span></dt><dd><p>Powder-averaged spectrum (absolute value).</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ShapedPulse_Bruker</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pulseLength</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">RotationAngle</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Hamiltonian.html#Hamiltonian.ShapedPulse_Bruker"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Load and process a shaped pulse from a Bruker shape file.</p>
<section id="id140">
<h4>Parameters:<a class="headerlink" href="#id140" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>file_path<span class="classifier">str</span></dt><dd><p>Path to the shaped pulse file (typically Bruker format)</p>
</dd>
<dt>pulseLength<span class="classifier">float</span></dt><dd><p>Total length of the shaped pulse (in seconds)</p>
</dd>
<dt>RotationAngle<span class="classifier">float</span></dt><dd><p>Desired rotation angle (in degrees)</p>
</dd>
</dl>
</section>
<section id="id141">
<h4>Returns:<a class="headerlink" href="#id141" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>tuple</dt><dd><p>(time array, B1 amplitude over time, B1 phase over time)</p>
</dd>
</dl>
</section>
<section id="references">
<h4>References:<a class="headerlink" href="#references" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p>Bruker Shape Tool manual</p></li>
<li><p><a class="reference external" href="https://github.com/modernscientist/">https://github.com/modernscientist/</a>…</p></li>
</ul>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ShapedPulse_Interpolate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">SPIntensity</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">SPPhase</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Kind</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Hamiltonian.html#Hamiltonian.ShapedPulse_Interpolate"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Interpolate amplitude and phase arrays of a shaped pulse.</p>
<section id="id142">
<h4>Parameters:<a class="headerlink" href="#id142" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>time<span class="classifier">array</span></dt><dd><p>Time axis of the pulse shape</p>
</dd>
<dt>SPIntensity<span class="classifier">array</span></dt><dd><p>Amplitude values of the pulse shape</p>
</dd>
<dt>SPPhase<span class="classifier">array</span></dt><dd><p>Phase values of the pulse shape (radians)</p>
</dd>
<dt>Kind<span class="classifier">str</span></dt><dd><p>Interpolation method (e.g., ‘linear’, ‘cubic’, etc.)</p>
</dd>
</dl>
</section>
<section id="id143">
<h4>Returns:<a class="headerlink" href="#id143" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>tuple</dt><dd><p>(amplitude interpolator, phase interpolator)</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Update</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Hamiltonian.html#Hamiltonian.Update"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Updates internal parameters from the QuantumSystem instance.
Useful when the quantum system is modified externally and 
the Hamiltonian needs to be resynchronized.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Zeeman</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Hamiltonian.html#Hamiltonian.Zeeman"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Constructs the Zeeman Hamiltonian in the laboratory frame.</p>
<p>The Zeeman Hamiltonian is defined as:</p>
<div class="math notranslate nohighlight">
\[H_Z = \sum_i \omega_{0i} \cdot S_{zi}\]</div>
<p>where <span class="math notranslate nohighlight">\(\omega_{0i}\)</span> is the Larmor frequency of the <em>i</em>-th spin,  
and <span class="math notranslate nohighlight">\(S_{zi}\)</span> is the z-component spin operator.</p>
<section id="id144">
<h4>Returns<a class="headerlink" href="#id144" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>QunObj</dt><dd><p>The Zeeman Hamiltonian represented as a quantum object.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Zeeman_B1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Omega1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Omega1Phase</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Hamiltonian.html#Hamiltonian.Zeeman_B1"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Constructs the B₁ Hamiltonian for RF excitation in the rotating frame.</p>
<dl class="simple">
<dt>Assumes a continuous wave RF field:</dt><dd><p>H_RF = ω₁ * [Sₓ cos(ϕ) + Sᵧ sin(ϕ)]</p>
</dd>
</dl>
<section id="id145">
<h4>Parameters:<a class="headerlink" href="#id145" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>Omega1<span class="classifier">float</span></dt><dd><p>RF amplitude in Hz (nutation frequency).</p>
</dd>
<dt>Omega1Phase<span class="classifier">float</span></dt><dd><p>RF phase in degrees.</p>
</dd>
</dl>
</section>
<section id="id146">
<h4>Returns:<a class="headerlink" href="#id146" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>QunObj</dt><dd><p>Time-independent B₁ Hamiltonian in rotating frame.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Zeeman_B1_Offresonance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Omega1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Omega1freq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Omega1Phase</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Hamiltonian.html#Hamiltonian.Zeeman_B1_Offresonance"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Constructs a time-dependent Zeeman Hamiltonian for an off-resonant RF field.</p>
<p>H(t) = ω₁ * [Sₓ cos(ω_RF * t + ϕ) + Sᵧ sin(ω_RF * t + ϕ)]</p>
<section id="id147">
<h4>Parameters:<a class="headerlink" href="#id147" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>t<span class="classifier">float</span></dt><dd><p>Time in seconds.</p>
</dd>
<dt>Omega1<span class="classifier">float</span></dt><dd><p>RF amplitude (nutation frequency in Hz).</p>
</dd>
<dt>Omega1freq<span class="classifier">float</span></dt><dd><p>RF frequency in Hz (off-resonance frequency in rotating frame).</p>
</dd>
<dt>Omega1Phase<span class="classifier">float</span></dt><dd><p>Initial phase in degrees.</p>
</dd>
</dl>
</section>
<section id="id148">
<h4>Returns:<a class="headerlink" href="#id148" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>numpy.ndarray</dt><dd><p>Time-dependent Hamiltonian matrix (not a QunObj).</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Zeeman_B1_ShapedPulse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Omega1T</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Omega1freq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Omega1PhaseT</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Hamiltonian.html#Hamiltonian.Zeeman_B1_ShapedPulse"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Constructs time-dependent B₁ Hamiltonian with shaped amplitude and phase (e.g., Gaussian).</p>
<section id="id149">
<h4>Parameters:<a class="headerlink" href="#id149" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>t<span class="classifier">float</span></dt><dd><p>Time (in seconds).</p>
</dd>
<dt>Omega1T<span class="classifier">callable</span></dt><dd><p>Function returning time-varying RF amplitude (Hz).</p>
</dd>
<dt>Omega1freq<span class="classifier">float</span></dt><dd><p>RF carrier frequency (Hz).</p>
</dd>
<dt>Omega1PhaseT<span class="classifier">callable</span></dt><dd><p>Function returning time-varying phase (radians).</p>
</dd>
</dl>
</section>
<section id="id150">
<h4>Returns:<a class="headerlink" href="#id150" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>numpy.ndarray</dt><dd><p>Time-dependent Hamiltonian matrix (not a QunObj).</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Zeeman_RotFrame</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Hamiltonian.html#Hamiltonian.Zeeman_RotFrame"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Constructs the Zeeman Hamiltonian in the rotating frame.</p>
<p>The Hamiltonian is defined as:</p>
<div class="math notranslate nohighlight">
\[H_Z^{\mathrm{RF}} = \sum_i \left( \omega_{0i} - \omega_{\mathrm{RF}i} \right) S_{zi}\]</div>
<p>where:
- <span class="math notranslate nohighlight">\(\omega_{0i}\)</span> is the Larmor frequency of the <em>i</em>-th spin
- <span class="math notranslate nohighlight">\(\omega_{\mathrm{RF}i}\)</span> is the rotating frame reference frequency</p>
<section id="id151">
<h4>Returns<a class="headerlink" href="#id151" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>QunObj</dt><dd><p>The Zeeman Hamiltonian in the rotating frame.</p>
</dd>
</dl>
</section>
</dd></dl>

</dd></dl>

</section>
</section>
<section id="hard-pulse-module">
<h2>Hard Pulse Module<a class="headerlink" href="#hard-pulse-module" title="Link to this heading"></a></h2>
<section id="hardpulse">
<h3><code class="xref py py-mod docutils literal notranslate"><span class="pre">HardPulse</span></code><a class="headerlink" href="#hardpulse" title="Link to this heading"></a></h3>
<p>PyOR - Python On Resonance</p>
<dl>
<dt>Author:</dt><dd><p>Vineeth Francis Thalakottoor Jose Chacko</p>
</dd>
<dt>Email:</dt><dd><p><a class="reference external" href="mailto:vineethfrancis&#46;physics&#37;&#52;&#48;gmail&#46;com">vineethfrancis<span>&#46;</span>physics<span>&#64;</span>gmail<span>&#46;</span>com</a></p>
</dd>
<dt>Description:</dt><dd><p>This file defines the <cite>HardPulse</cite> class, which implements methods for handling 
rotation (pulse) operations in both Hilbert and Liouville spaces as applied 
in magnetic resonance simulations.</p>
<p>The <cite>HardPulse</cite> class supports the construction of rotation operators, 
pulse applications, and conversions between different quantum mechanical 
representations.</p>
</dd>
</dl>
<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">HardPulse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">class_QS</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_HardPulse.html#HardPulse"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Matrix_Tol</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_HardPulse.html#HardPulse.Matrix_Tol"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Set elements of a matrix below a threshold tolerance to zero.</p>
<section id="id152">
<h4>Parameters<a class="headerlink" href="#id152" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>M<span class="classifier">np.ndarray</span></dt><dd><p>Input matrix to clean.</p>
</dd>
</dl>
</section>
<section id="id153">
<h4>Returns<a class="headerlink" href="#id153" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>np.ndarray</dt><dd><p>Matrix with small values zeroed out.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Rotate_CyclicPermutation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">AQ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">BS</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_HardPulse.html#HardPulse.Rotate_CyclicPermutation"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Rotate operator BS about operator AQ using cyclic commutation relations.</p>
<p>This method applies an analytical rotation based on the cyclic commutator rule:
If [A, B] = jC, then the rotation of B about A by angle θ is given by:</p>
<blockquote>
<div><dl class="simple">
<dt>EXP(-j A * θ) &#64; B &#64; EXP(j A * θ) </dt><dd><p>= B * cos(θ) - j * [A, B] * sin(θ) 
= B * cos(θ) + C * sin(θ)</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>where:</dt><dd><p>A : Operator about which rotation is applied
B : Operator being rotated
C : Operator resulting from the commutator [A, B] = jC
j : imaginary unit</p>
</dd>
</dl>
<section id="id154">
<h4>Parameters<a class="headerlink" href="#id154" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>AQ<span class="classifier">QunObj</span></dt><dd><p>Operator A about which the rotation happens.</p>
</dd>
<dt>BS<span class="classifier">QunObj</span></dt><dd><p>Operator B to be rotated.</p>
</dd>
<dt>theta<span class="classifier">float</span></dt><dd><p>Rotation angle in degrees.</p>
</dd>
</dl>
</section>
<section id="id155">
<h4>Returns<a class="headerlink" href="#id155" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>QunObj</dt><dd><p>Rotated operator.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Rotate_Pulse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rhoQ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta_rad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operatorQ</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_HardPulse.html#HardPulse.Rotate_Pulse"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Perform rotation on an operator or state under a pulse.</p>
<p>This applies the unitary rotation: exp(-iθA) ρ exp(iθA)</p>
<section id="id156">
<h4>Parameters<a class="headerlink" href="#id156" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>rhoQ<span class="classifier">QunObj</span></dt><dd><p>Density matrix or operator to be rotated.</p>
</dd>
<dt>theta_rad<span class="classifier">float</span></dt><dd><p>Rotation angle in degrees.</p>
</dd>
<dt>operatorQ<span class="classifier">QunObj</span></dt><dd><p>Operator generating the rotation (e.g., Ix, Iy, Iz).</p>
</dd>
</dl>
</section>
<section id="id157">
<h4>Returns<a class="headerlink" href="#id157" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>QunObj</dt><dd><p>Rotated operator or state.</p>
</dd>
</dl>
</section>
</dd></dl>

</dd></dl>

</section>
</section>
<section id="maser-data-analyzer-module">
<h2>Maser Data Analyzer Module<a class="headerlink" href="#maser-data-analyzer-module" title="Link to this heading"></a></h2>
<section id="maserdataanalyzer">
<h3><code class="xref py py-mod docutils literal notranslate"><span class="pre">MaserDataAnalyzer</span></code><a class="headerlink" href="#maserdataanalyzer" title="Link to this heading"></a></h3>
<p>PyOR - Python On Resonance</p>
<dl>
<dt>Author:</dt><dd><p>Vineeth Francis Thalakottoor Jose Chacko</p>
</dd>
<dt>Email:</dt><dd><p><a class="reference external" href="mailto:vineethfrancis&#46;physics&#37;&#52;&#48;gmail&#46;com">vineethfrancis<span>&#46;</span>physics<span>&#64;</span>gmail<span>&#46;</span>com</a></p>
</dd>
<dt>Description:</dt><dd><p>This module provides the <cite>MaserDataAnalyzer</cite> class for loading, analyzing,
and visualizing maser signal data in both time and frequency domains.</p>
<p>It includes interactive matplotlib visualizations for signal inspection,
FFT/iFFT transformations, and automatic subplot saving after user interactions.</p>
</dd>
</dl>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Bruker1Ddata</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filepath</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">outname</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_MaserDataAnalyzer.html#Bruker1Ddata"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Converts a Bruker ‘fid’ file into a CSV with Mx and My columns only.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>filepath (str): Path to the Bruker ‘fid’ binary file.
outname (str): Output CSV filename (with or without .csv extension).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Bruker2Ddata</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filepath</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">TD_F1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">FIDno</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">outname</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_MaserDataAnalyzer.html#Bruker2Ddata"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Extract and save a specific FID (Free Induction Decay) from Bruker 2D NMR data.</p>
<p>This function reads a Bruker 2D “ser” file, extracts the specified FID number,
and saves its real and imaginary components into a CSV file.</p>
<section id="id158">
<h4>Parameters<a class="headerlink" href="#id158" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>filepath<span class="classifier">str</span></dt><dd><p>Path to the Bruker “ser” file containing the raw 2D NMR data.</p>
</dd>
<dt>TD_F1<span class="classifier">int</span></dt><dd><p>The size of the indirect dimension (F1) of the dataset.</p>
</dd>
<dt>FIDno<span class="classifier">int</span></dt><dd><p>The number of the FID to extract (0-based indexing).</p>
</dd>
<dt>outname<span class="classifier">str</span></dt><dd><p>The desired output CSV file name. 
If the extension is not provided, “.csv” will be appended automatically.</p>
</dd>
</dl>
</section>
<section id="id159">
<h4>Notes<a class="headerlink" href="#id159" title="Link to this heading"></a></h4>
<p>The output CSV will contain two columns:
- First column: Real part of the FID.
- Second column: Imaginary part of the FID.
Each row corresponds to a point in the FID.</p>
</section>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Fourier</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Mx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">My</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spectrum</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fig</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">line1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">line2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">line3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">line4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vline1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vline2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vline3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vline4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">text1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">text2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Flip_Sp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Abs_Sp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filepath</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_MaserDataAnalyzer.html#Fourier"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Fourier handles interactive user selections and signal processing
for visualizing and analyzing time-frequency domain relationships.</p>
<p>Supports:
- Selecting a time window and computing its FFT
- Selecting a frequency window and reconstructing signal via iFFT
- Saving updated subplots without altering the original interactive plot</p>
<dl class="simple">
<dt>Attributes:</dt><dd><p>ax (2D array of Axes): Grid of matplotlib axes (2x2)
fig (Figure): The main matplotlib figure
spectrum (np.ndarray): Full FFT spectrum of the original signal
flip_spectrum (bool): Whether the spectrum is reversed
abs_spectrum (bool): Whether to show magnitude or raw FFT values</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">button_press</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">event</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_MaserDataAnalyzer.html#Fourier.button_press"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Captures initial mouse press location in relevant subplot.
Used for selecting a time or frequency window.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">button_release</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">event</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_MaserDataAnalyzer.html#Fourier.button_release"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Captures mouse release and handles the following:
- Computes FFT from selected time range
- Computes iFFT from selected frequency range
- Updates the corresponding subplots
- Saves the subplots to disk (without modifying originals)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">save_subplot_from_axis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ax</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">outdir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'SavedPlots'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_MaserDataAnalyzer.html#Fourier.save_subplot_from_axis"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Saves a clean copy of the specified axis to a PNG file.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>ax (matplotlib.axes.Axes): The axis to save.
filename (str): The name of the file (e.g., ‘fft_of_selection.png’).
outdir (str): Output folder to save the files.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">MaserDataAnalyzer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filepath</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flip_spectrum</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">abs_spectrum</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">simulation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_MaserDataAnalyzer.html#MaserDataAnalyzer"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>MaserDataAnalyzer handles loading, processing, and plotting of maser data.</p>
<dl class="simple">
<dt>Attributes:</dt><dd><p>filepath (str): Path to the CSV file containing maser signal data.
offset (float): Frequency offset for spectrum display.
flip_spectrum (bool): Flag to reverse the spectrum.
abs_spectrum (bool): Flag to display absolute value of the FFT.
dt (float): Time step between signal points.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Compute_FFT</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_MaserDataAnalyzer.html#MaserDataAnalyzer.Compute_FFT"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Computes and prepares the FFT spectrum for display.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Connect_Events</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_MaserDataAnalyzer.html#MaserDataAnalyzer.Connect_Events"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Binds mouse events for interaction.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Load_Data</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_MaserDataAnalyzer.html#MaserDataAnalyzer.Load_Data"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Loads maser signal data from a CSV file.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Plot</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_MaserDataAnalyzer.html#MaserDataAnalyzer.Plot"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Plot_FFT</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_MaserDataAnalyzer.html#MaserDataAnalyzer.Plot_FFT"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Plots the frequency-domain spectrum only.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Plot_Mx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Mx_list</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_MaserDataAnalyzer.html#MaserDataAnalyzer.Plot_Mx"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Plot all the Mx arrays from a list of file names and save the figure.</p>
<dl class="simple">
<dt>Parameters:</dt><dd><dl class="simple">
<dt>Mx_list (list of str):</dt><dd><p>List of base names of <cite>.npy</cite> files (without the <cite>.npy</cite> extension),
located in the same directory as <cite>self.filepath</cite>.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Plot_Mz</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Mz_list</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_MaserDataAnalyzer.html#MaserDataAnalyzer.Plot_Mz"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Plot multiple Mz arrays and save the combined figure.</p>
<dl class="simple">
<dt>Parameters:</dt><dd><dl class="simple">
<dt>Mz_list (list of str):</dt><dd><p>A list of base names of <cite>.npy</cite> files (without the <cite>.npy</cite> extension),
located in the same directory as <cite>self.filepath</cite>.
Each <cite>.npy</cite> file contains a 1D array representing Mz.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Plot_Signal</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_MaserDataAnalyzer.html#MaserDataAnalyzer.Plot_Signal"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Plots the time-domain signal only.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Prepare_Signal</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_MaserDataAnalyzer.html#MaserDataAnalyzer.Prepare_Signal"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Creates a complex signal from Mx and My components.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Setup_Plot</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_MaserDataAnalyzer.html#MaserDataAnalyzer.Setup_Plot"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Creates and configures a 2x2 subplot grid.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Show</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_MaserDataAnalyzer.html#MaserDataAnalyzer.Show"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Displays the interactive plot window.</p>
</dd></dl>

</dd></dl>

</section>
</section>
<section id="nonlinear-nmr-module">
<h2>Nonlinear NMR Module<a class="headerlink" href="#nonlinear-nmr-module" title="Link to this heading"></a></h2>
<section id="nonlinearnmr">
<h3><code class="xref py py-mod docutils literal notranslate"><span class="pre">NonlinearNMR</span></code><a class="headerlink" href="#nonlinearnmr" title="Link to this heading"></a></h3>
<p>PyOR - Python On Resonance</p>
<dl>
<dt>Author:</dt><dd><p>Vineeth Francis Thalakottoor Jose Chacko</p>
</dd>
<dt>Email:</dt><dd><p><a class="reference external" href="mailto:vineethfrancis&#46;physics&#37;&#52;&#48;gmail&#46;com">vineethfrancis<span>&#46;</span>physics<span>&#64;</span>gmail<span>&#46;</span>com</a></p>
</dd>
<dt>Description:</dt><dd><p>This file defines the <cite>NonLinear</cite> class, which provides utilities for incorporating 
non-linear effects such as radiation damping, dipolar shifts, and Gaussian noise 
into spin dynamics simulations in nuclear magnetic resonance (NMR).</p>
<p>The <cite>NonLinear</cite> class enables the simulation of complex feedback mechanisms 
that are critical for modeling real-world magnetic 
resonance experiments.</p>
</dd>
</dl>
<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">NonLinear</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">class_QS</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_NonlinearNMR.html#NonLinear"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DipoleShift</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_NonlinearNMR.html#NonLinear.DipoleShift"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute dipolar shift from the current density matrix.</p>
<section id="id160">
<h4>Parameters<a class="headerlink" href="#id160" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>rho<span class="classifier">np.ndarray</span></dt><dd><p>Density matrix of the system.</p>
</dd>
</dl>
</section>
<section id="id161">
<h4>Returns<a class="headerlink" href="#id161" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>float</dt><dd><p>Average dipolar field shift along z-direction.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Noise_Gaussian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N_mean</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N_std</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N_length</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_NonlinearNMR.html#NonLinear.Noise_Gaussian"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Generate Gaussian noise samples.</p>
<section id="id162">
<h4>Parameters<a class="headerlink" href="#id162" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>N_mean<span class="classifier">float</span></dt><dd><p>Mean of the Gaussian distribution.</p>
</dd>
<dt>N_std<span class="classifier">float</span></dt><dd><p>Standard deviation of the Gaussian distribution.</p>
</dd>
<dt>N_length<span class="classifier">int</span></dt><dd><p>Number of random samples to generate.</p>
</dd>
</dl>
</section>
<section id="id163">
<h4>Returns<a class="headerlink" href="#id163" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>np.ndarray</dt><dd><p>An array of random noise values or zeros depending on configuration.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Radiation_Damping</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_NonlinearNMR.html#NonLinear.Radiation_Damping"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute the radiation damping field based on the system state.</p>
<p>This function calculates the transverse magnetization contributions
to radiation damping and optionally adds spin noise in two different
ways depending on simulation settings.</p>
<section id="id164">
<h4>Parameters<a class="headerlink" href="#id164" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>rho<span class="classifier">np.ndarray</span></dt><dd><p>Density matrix of the spin system.</p>
</dd>
</dl>
</section>
<section id="id165">
<h4>Returns<a class="headerlink" href="#id165" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>complex</dt><dd><p>The effective radiation damping field including optional noise.
Real part corresponds to the x-component, imaginary part to y-component.</p>
</dd>
</dl>
</section>
</dd></dl>

</dd></dl>

</section>
</section>
<section id="particle-module">
<h2>Particle Module<a class="headerlink" href="#particle-module" title="Link to this heading"></a></h2>
<section id="particle">
<h3><code class="xref py py-mod docutils literal notranslate"><span class="pre">Particle</span></code><a class="headerlink" href="#particle" title="Link to this heading"></a></h3>
<p>PyOR - Python On Resonance</p>
<dl class="simple">
<dt>Author:</dt><dd><p>Vineeth Francis Thalakottoor Jose Chacko</p>
</dd>
<dt>Email:</dt><dd><p><a class="reference external" href="mailto:vineethfrancis&#46;physics&#37;&#52;&#48;gmail&#46;com">vineethfrancis<span>&#46;</span>physics<span>&#64;</span>gmail<span>&#46;</span>com</a></p>
</dd>
<dt>Description:</dt><dd><p>This file defines the <cite>Particle</cite> class, which represents a quantum particle 
with properties relevant to magnetic resonance simulations.</p>
</dd>
<dt>Attributes:</dt><dd><dl class="simple">
<dt>name (str): </dt><dd><p>The name of the particle (e.g., ‘1H’, ‘13C’, ‘Electron’).</p>
</dd>
<dt>spin (float): </dt><dd><p>The spin quantum number of the particle.</p>
</dd>
<dt>gamma (float): </dt><dd><p>The gyromagnetic ratio of the particle (in rad/s/T).</p>
</dd>
<dt>quadrupole (float): </dt><dd><p>The quadrupole moment of the particle (if applicable, otherwise zero).</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">particle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Particle.html#particle"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
</dd></dl>

</section>
</section>
<section id="phase-cycle-module">
<h2>Phase Cycle Module<a class="headerlink" href="#phase-cycle-module" title="Link to this heading"></a></h2>
<section id="phasecycle">
<h3><code class="xref py py-mod docutils literal notranslate"><span class="pre">PhaseCycle</span></code><a class="headerlink" href="#phasecycle" title="Link to this heading"></a></h3>
<p>PyOR - Python On Resonance</p>
<dl>
<dt>Author:</dt><dd><p>Vineeth Francis Thalakottoor Jose Chacko</p>
</dd>
<dt>Email:</dt><dd><p><a class="reference external" href="mailto:vineethfrancis&#46;physics&#37;&#52;&#48;gmail&#46;com">vineethfrancis<span>&#46;</span>physics<span>&#64;</span>gmail<span>&#46;</span>com</a></p>
</dd>
<dt>Description:</dt><dd><p>This file defines the <cite>PhaseCycle</cite> class, which handles phase cycling operations 
including pulse phasing and receiver phase adjustments in magnetic resonance simulations.</p>
<p>Phase cycling is a crucial technique for eliminating unwanted coherence pathways 
and improving signal-to-noise ratios in NMR and EPR experiments.</p>
</dd>
</dl>
<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">PhaseCycle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">class_QS</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_PhaseCycle.html#PhaseCycle"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Pulse_Phase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">SxQ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">SyQ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phase</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_PhaseCycle.html#PhaseCycle.Pulse_Phase"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Construct a pulse operator along a defined phase direction.</p>
<p>This generates a combined spin operator that simulates a pulse 
along the direction defined by <cite>phase</cite>:
Pulse Operator = cos(phase) * Sx + sin(phase) * Sy</p>
<section id="id166">
<h4>Parameters<a class="headerlink" href="#id166" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>SxQ<span class="classifier">QunObj</span></dt><dd><p>Sx spin operator (should be a list of matrices or summed operator).</p>
</dd>
<dt>SyQ<span class="classifier">QunObj</span></dt><dd><p>Sy spin operator (same dimensions as SxQ).</p>
</dd>
<dt>phase<span class="classifier">float</span></dt><dd><p>Desired phase angle in degrees.</p>
</dd>
</dl>
</section>
<section id="id167">
<h4>Returns<a class="headerlink" href="#id167" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>QunObj</dt><dd><p>Spin operator for rotation about the defined phase axis.</p>
</dd>
</dl>
</section>
<section id="id168">
<h4>Raises<a class="headerlink" href="#id168" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>TypeError</dt><dd><p>If inputs are not instances of QunObj.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Receiver_Phase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">SxQ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">SyQ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phase</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_PhaseCycle.html#PhaseCycle.Receiver_Phase"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Construct a receiver (detection) operator with a defined phase.</p>
<p>This rotates the detection operator (Sx + iSy) by the specified receiver phase:
Detection Operator = (Sx + i*Sy) * exp(i * phase)</p>
<section id="id169">
<h4>Parameters<a class="headerlink" href="#id169" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>SxQ<span class="classifier">QunObj</span></dt><dd><p>Sx spin operator.</p>
</dd>
<dt>SyQ<span class="classifier">QunObj</span></dt><dd><p>Sy spin operator.</p>
</dd>
<dt>phase<span class="classifier">float</span></dt><dd><p>Receiver phase in degrees.</p>
</dd>
</dl>
</section>
<section id="id170">
<h4>Returns<a class="headerlink" href="#id170" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>QunObj</dt><dd><p>Complex detection operator after phase adjustment.</p>
</dd>
</dl>
</section>
<section id="id171">
<h4>Raises<a class="headerlink" href="#id171" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>TypeError</dt><dd><p>If inputs are not instances of QunObj.</p>
</dd>
</dl>
</section>
</dd></dl>

</dd></dl>

</section>
</section>
<section id="physical-constants-module">
<h2>Physical Constants Module<a class="headerlink" href="#physical-constants-module" title="Link to this heading"></a></h2>
<section id="physicalconstants">
<h3><code class="xref py py-mod docutils literal notranslate"><span class="pre">PhysicalConstants</span></code><a class="headerlink" href="#physicalconstants" title="Link to this heading"></a></h3>
<p>PyOR - Python On Resonance</p>
<dl>
<dt>Author:</dt><dd><p>Vineeth Francis Thalakottoor Jose Chacko</p>
</dd>
<dt>Email:</dt><dd><p><a class="reference external" href="mailto:vineethfrancis&#46;physics&#37;&#52;&#48;gmail&#46;com">vineethfrancis<span>&#46;</span>physics<span>&#64;</span>gmail<span>&#46;</span>com</a></p>
</dd>
<dt>Description:</dt><dd><p>This module provides commonly used physical constants relevant to magnetic resonance 
simulations, including Planck’s constant, Boltzmann constant, magnetic permeability, 
and elementary charge.</p>
<p>These constants are critical for calculating resonance conditions, thermal polarization, 
and magnetic interactions.</p>
</dd>
</dl>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">constants</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_PhysicalConstants.html#constants"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Returns the value of a fundamental physical constant.</p>
<p>This function provides access to a dictionary of commonly used physical constants 
in quantum mechanics, electromagnetism, and thermodynamics. The values are given 
in SI units unless otherwise specified.</p>
<section id="id172">
<h4>Parameters:<a class="headerlink" href="#id172" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>value<span class="classifier">str</span></dt><dd><dl class="simple">
<dt>The key representing the desired constant. Available keys include:</dt><dd><ul class="simple">
<li><p>“pl”   : Planck constant (h), in joule·seconds (J·s)</p></li>
<li><p>“hbar” : Reduced Planck constant (ħ = h / 2π), in joule·seconds per radian (J·s·rad⁻¹)</p></li>
<li><p>“ep0”  : Vacuum permittivity (ε₀), in farads per meter (F·m⁻¹)</p></li>
<li><p>“mu0”  : Vacuum permeability (μ₀), in newtons per ampere squared (N·A⁻²) or henries per meter (H·m⁻¹)</p></li>
<li><p>“kb”   : Boltzmann constant (k_B), in joules per kelvin (J·K⁻¹)</p></li>
<li><p>“bm”   : Bohr magneton (μ_B), in joules per tesla (J·T⁻¹)</p></li>
<li><p>“nm”   : Nuclear magneton (μ_N), in joules per tesla (J·T⁻¹)</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
</section>
<section id="id173">
<h4>Returns:<a class="headerlink" href="#id173" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>float</dt><dd><p>The numerical value of the requested physical constant in SI units.</p>
</dd>
</dl>
</section>
<section id="id174">
<h4>Raises:<a class="headerlink" href="#id174" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>AssertionError</dt><dd><p>If the specified key is not found in the <cite>CONSTANTS</cite> dictionary.
Users may add new constants manually if needed.</p>
</dd>
</dl>
</section>
<section id="id175">
<h4>Example:<a class="headerlink" href="#id175" title="Link to this heading"></a></h4>
<p>constants(“pl”)
6.626e-34</p>
<p>constants(“kb”)
1.380649e-23</p>
</section>
</dd></dl>

</section>
</section>
<section id="plotting-module">
<h2>Plotting Module<a class="headerlink" href="#plotting-module" title="Link to this heading"></a></h2>
<section id="plotting">
<h3><code class="xref py py-mod docutils literal notranslate"><span class="pre">Plotting</span></code><a class="headerlink" href="#plotting" title="Link to this heading"></a></h3>
<p>PyOR - Python On Resonance</p>
<dl>
<dt>Author:</dt><dd><p>Vineeth Francis Thalakottoor Jose Chacko</p>
</dd>
<dt>Email:</dt><dd><p><a class="reference external" href="mailto:vineethfrancis&#46;physics&#37;&#52;&#48;gmail&#46;com">vineethfrancis<span>&#46;</span>physics<span>&#64;</span>gmail<span>&#46;</span>com</a></p>
</dd>
<dt>Description:</dt><dd><p>This module defines the <cite>Plotting</cite> class, which provides visualization utilities 
for PyOR simulations.</p>
<p>The <cite>Plotting</cite> class includes functions for plotting time-domain signals, frequency spectra, 
evolution of density matrices, and other data relevant to magnetic resonance experiments.</p>
</dd>
</dl>
<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Fanalyzer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Mx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">My</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fig</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">line1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">line2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">line3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">line4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vline1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vline2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vline3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vline4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">text1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">text2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Plotting.html#Fanalyzer"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Interactive Fourier analyzer for visualizing time-frequency transformations.</p>
<p>This class enables interactive selection and analysis of signal portions
in time and frequency domains. It links two time-domain and two frequency-domain
plots together, enabling dynamic visual feedback.</p>
<section id="id176">
<h4>Parameters<a class="headerlink" href="#id176" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>Mx<span class="classifier">ndarray</span></dt><dd><p>Real part of the signal (time domain).</p>
</dd>
<dt>My<span class="classifier">ndarray</span></dt><dd><p>Imaginary part of the signal (time domain).</p>
</dd>
<dt>ax<span class="classifier">ndarray of Axes</span></dt><dd><p>2x2 array of matplotlib Axes objects.</p>
</dd>
<dt>fig<span class="classifier">matplotlib.figure.Figure</span></dt><dd><p>The figure containing the subplots.</p>
</dd>
<dt>line1<span class="classifier">Line2D</span></dt><dd><p>Plot handle for time-domain signal (top left).</p>
</dd>
<dt>line2<span class="classifier">Line2D</span></dt><dd><p>Plot handle for full spectrum (top right).</p>
</dd>
<dt>line3<span class="classifier">Line2D</span></dt><dd><p>Plot handle for second spectrum (bottom left).</p>
</dd>
<dt>line4<span class="classifier">Line2D</span></dt><dd><p>Plot handle for reconstructed signal (bottom right).</p>
</dd>
<dt>vline1, vline2, vline3, vline4<span class="classifier">Line2D</span></dt><dd><p>Vertical lines indicating selection on plots.</p>
</dd>
<dt>text1, text2<span class="classifier">Text</span></dt><dd><p>Text annotations for selected range (frequency/time).</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">button_press</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">event</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Plotting.html#Fanalyzer.button_press"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Handle mouse press event for interactive selection.</p>
<section id="id177">
<h5>Parameters<a class="headerlink" href="#id177" title="Link to this heading"></a></h5>
<dl class="simple">
<dt>event<span class="classifier">matplotlib.backend_bases.MouseEvent</span></dt><dd><p>Mouse press event.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">button_release</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">event</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Plotting.html#Fanalyzer.button_release"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Handle mouse release event and update plots based on selection.</p>
<section id="id178">
<h5>Parameters<a class="headerlink" href="#id178" title="Link to this heading"></a></h5>
<dl class="simple">
<dt>event<span class="classifier">matplotlib.backend_bases.MouseEvent</span></dt><dd><p>Mouse release event.</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Plotting</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">class_QS</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Plotting.html#Plotting"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InnerProduct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Plotting.html#Plotting.InnerProduct"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Calculate the inner product of two matrices or vectors.</p>
<p>This uses the definition of the inner product as Tr(A†B), where A† is the conjugate transpose of A.</p>
<section id="id179">
<h4>Parameters<a class="headerlink" href="#id179" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>A<span class="classifier">ndarray</span></dt><dd><p>First operator or vector.</p>
</dd>
<dt>B<span class="classifier">ndarray</span></dt><dd><p>Second operator or vector.</p>
</dd>
</dl>
</section>
<section id="id180">
<h4>Returns<a class="headerlink" href="#id180" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>complex</dt><dd><p>The inner product value as a complex number.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MatrixPlot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xlabel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ylabel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">saveplt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Plotting.html#Plotting.MatrixPlot"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Plot a 2D color map of a matrix with labels.</p>
<section id="id181">
<h4>Parameters<a class="headerlink" href="#id181" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>M<span class="classifier">ndarray</span></dt><dd><p>Matrix to be plotted.</p>
</dd>
<dt>xlabel<span class="classifier">list of str</span></dt><dd><p>Labels for x-axis.</p>
</dd>
<dt>ylabel<span class="classifier">list of str</span></dt><dd><p>Labels for y-axis.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MatrixPlot3D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xlabel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ylabel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">saveplt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Plotting.html#Plotting.MatrixPlot3D"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Create a 3D bar plot of matrix values.</p>
<section id="id182">
<h4>Parameters<a class="headerlink" href="#id182" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>rho<span class="classifier">ndarray</span></dt><dd><p>Matrix to be plotted (2D).</p>
</dd>
<dt>xlabel<span class="classifier">list of str</span></dt><dd><p>Labels for x-axis.</p>
</dd>
<dt>ylabel<span class="classifier">list of str</span></dt><dd><p>Labels for y-axis.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MatrixPlot_slider</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho_t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xlabel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ylabel</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Plotting.html#Plotting.MatrixPlot_slider"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Plot a time-dependent matrix with a slider to change time steps.</p>
<section id="id183">
<h4>Parameters<a class="headerlink" href="#id183" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>t<span class="classifier">ndarray</span></dt><dd><p>Array of time points.</p>
</dd>
<dt>rho_t<span class="classifier">ndarray</span></dt><dd><p>Array of matrices over time (len(t) x N x N).</p>
</dd>
<dt>xlabel<span class="classifier">list of str</span></dt><dd><p>X-axis labels.</p>
</dd>
<dt>ylabel<span class="classifier">list of str</span></dt><dd><p>Y-axis labels.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Plotting</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xlab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ylab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">col</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">saveplt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Plotting.html#Plotting.Plotting"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Plot a simple 2D line graph.</p>
<section id="id184">
<h4>Parameters<a class="headerlink" href="#id184" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>x<span class="classifier">array_like</span></dt><dd><p>Array containing data for the x-axis.</p>
</dd>
<dt>y<span class="classifier">array_like</span></dt><dd><p>Array containing data for the y-axis.</p>
</dd>
<dt>xlab<span class="classifier">str</span></dt><dd><p>Label for the x-axis.</p>
</dd>
<dt>ylab<span class="classifier">str</span></dt><dd><p>Label for the y-axis.</p>
</dd>
<dt>col<span class="classifier">str</span></dt><dd><p>Color code or name for the plot line.</p>
</dd>
</dl>
</section>
<section id="id185">
<h4>Returns<a class="headerlink" href="#id185" title="Link to this heading"></a></h4>
<p>None</p>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Plotting3DWire</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xlab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ylab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">title</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upL</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loL</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">saveplt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Plotting.html#Plotting.Plotting3DWire"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Plot a 3D wireframe surface using meshgrid data.</p>
<section id="id186">
<h4>Parameters<a class="headerlink" href="#id186" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>x<span class="classifier">ndarray</span></dt><dd><p>1D array for x-axis values.</p>
</dd>
<dt>y<span class="classifier">ndarray</span></dt><dd><p>1D array for y-axis values.</p>
</dd>
<dt>z<span class="classifier">2D ndarray</span></dt><dd><p>Matrix of z-values defining the surface height.</p>
</dd>
<dt>xlab<span class="classifier">str</span></dt><dd><p>Label for the x-axis.</p>
</dd>
<dt>ylab<span class="classifier">str</span></dt><dd><p>Label for the y-axis.</p>
</dd>
<dt>title<span class="classifier">str</span></dt><dd><p>Title of the plot.</p>
</dd>
<dt>upL<span class="classifier">float</span></dt><dd><p>Upper limit for the X and Y axes.</p>
</dd>
<dt>loL<span class="classifier">float</span></dt><dd><p>Lower limit for the X and Y axes.</p>
</dd>
</dl>
</section>
<section id="id187">
<h4>Returns<a class="headerlink" href="#id187" title="Link to this heading"></a></h4>
<p>None</p>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlottingContour</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xlab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ylab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">title</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">saveplt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Plotting.html#Plotting.PlottingContour"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Generate a contour plot of a 2D scalar field.</p>
<section id="id188">
<h4>Parameters<a class="headerlink" href="#id188" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>x<span class="classifier">ndarray</span></dt><dd><p>1D array of x-axis values.</p>
</dd>
<dt>y<span class="classifier">ndarray</span></dt><dd><p>1D array of y-axis values.</p>
</dd>
<dt>z<span class="classifier">ndarray</span></dt><dd><p>2D array of z values, representing the scalar field.</p>
</dd>
<dt>xlab<span class="classifier">str</span></dt><dd><p>Label for the x-axis.</p>
</dd>
<dt>ylab<span class="classifier">str</span></dt><dd><p>Label for the y-axis.</p>
</dd>
<dt>title<span class="classifier">str</span></dt><dd><p>Title of the contour plot.</p>
</dd>
</dl>
</section>
<section id="id189">
<h4>Returns<a class="headerlink" href="#id189" title="Link to this heading"></a></h4>
<p>None</p>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlottingMulti</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xlab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ylab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">col</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">saveplt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Plotting.html#Plotting.PlottingMulti"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Plot multiple signals on a single set of axes.</p>
<section id="id190">
<h4>Parameters<a class="headerlink" href="#id190" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>x<span class="classifier">list of array_like</span></dt><dd><p>List of X-axis data arrays, each corresponding to one line.</p>
</dd>
<dt>y<span class="classifier">list of array_like</span></dt><dd><p>List of Y-axis data arrays, each corresponding to one line.</p>
</dd>
<dt>xlab<span class="classifier">str</span></dt><dd><p>Label for the X-axis.</p>
</dd>
<dt>ylab<span class="classifier">str</span></dt><dd><p>Label for the Y-axis.</p>
</dd>
<dt>col<span class="classifier">list of str</span></dt><dd><p>Colors for each plotted line.</p>
</dd>
</dl>
</section>
<section id="id191">
<h4>Returns<a class="headerlink" href="#id191" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>None</dt><dd><p>Displays the plot with multiple signals.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlottingMulti_SpanSelector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xlab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ylab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">col</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">saveplt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Plotting.html#Plotting.PlottingMulti_SpanSelector"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Plot multiple signals with a horizontal span selector for interactive range selection.</p>
<section id="id192">
<h4>Parameters<a class="headerlink" href="#id192" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>x<span class="classifier">list of array_like</span></dt><dd><p>List of X-axis data arrays for each plotted line.</p>
</dd>
<dt>y<span class="classifier">list of array_like</span></dt><dd><p>List of Y-axis data arrays for each plotted line.</p>
</dd>
<dt>xlab<span class="classifier">str</span></dt><dd><p>Label for the X-axis.</p>
</dd>
<dt>ylab<span class="classifier">str</span></dt><dd><p>Label for the Y-axis.</p>
</dd>
<dt>col<span class="classifier">list of str</span></dt><dd><p>List of color values corresponding to each data series.</p>
</dd>
</dl>
</section>
<section id="id193">
<h4>Returns<a class="headerlink" href="#id193" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>tuple</dt><dd><dl class="simple">
<dt>fig<span class="classifier">matplotlib.figure.Figure</span></dt><dd><p>The generated figure object.</p>
</dd>
<dt>span_selector<span class="classifier">matplotlib.widgets.SpanSelector</span></dt><dd><p>The interactive span selector widget.</p>
</dd>
</dl>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlottingMultimodeAnalyzer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sig</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">saveplt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Plotting.html#Plotting.PlottingMultimodeAnalyzer"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Multimode Fourier Analyzer with interactive plot linking time and frequency domains.</p>
<section id="id194">
<h4>Parameters<a class="headerlink" href="#id194" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>t<span class="classifier">array_like</span></dt><dd><p>Time-domain sampling points.</p>
</dd>
<dt>freq<span class="classifier">array_like</span></dt><dd><p>Frequency-domain sampling points.</p>
</dd>
<dt>sig<span class="classifier">array_like</span></dt><dd><p>Complex-valued signal in the time domain (FID).</p>
</dd>
<dt>spec<span class="classifier">array_like</span></dt><dd><p>Corresponding spectrum of the signal.</p>
</dd>
</dl>
</section>
<section id="id195">
<h4>Returns<a class="headerlink" href="#id195" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>fig<span class="classifier">matplotlib.figure.Figure</span></dt><dd><p>The main figure object.</p>
</dd>
<dt>fourier<span class="classifier">Fanalyzer</span></dt><dd><p>An instance of the Fanalyzer class for interaction handling.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlottingSphere</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Mx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">My</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Mz</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho_eqQ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_vector</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale_datapoints</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">saveplt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Plotting.html#Plotting.PlottingSphere"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Plot the evolution of magnetization on a Bloch sphere.</p>
<section id="id196">
<h4>Parameters<a class="headerlink" href="#id196" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>Mx<span class="classifier">array_like</span></dt><dd><p>Array of Mx components over time.</p>
</dd>
<dt>My<span class="classifier">array_like</span></dt><dd><p>Array of My components over time.</p>
</dd>
<dt>Mz<span class="classifier">array_like</span></dt><dd><p>Array of Mz components over time.</p>
</dd>
<dt>rho_eqQ<span class="classifier">QuantumState</span></dt><dd><p>Equilibrium density matrix wrapped in a custom object.</p>
</dd>
<dt>plot_vector<span class="classifier">bool</span></dt><dd><p>If True, individual magnetization vectors are shown as arrows.</p>
</dd>
<dt>scale_datapoints<span class="classifier">int</span></dt><dd><p>Controls downsampling of the time points shown.</p>
</dd>
</dl>
</section>
<section id="id197">
<h4>Returns<a class="headerlink" href="#id197" title="Link to this heading"></a></h4>
<p>None</p>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlottingTwin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xlab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ylab1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ylab2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">col1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">col2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">saveplt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Plotting.html#Plotting.PlottingTwin"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Plot two signals with twin Y-axes.</p>
<p>This method generates a plot where <cite>y1</cite> is plotted against <cite>x</cite> on the left Y-axis,
and <cite>y2</cite> is plotted against <cite>x</cite> on a secondary Y-axis (right), allowing comparison
of two signals with different scales.</p>
<section id="id198">
<h4>Parameters<a class="headerlink" href="#id198" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>x<span class="classifier">array_like</span></dt><dd><p>1D array for the X-axis data.</p>
</dd>
<dt>y1<span class="classifier">array_like</span></dt><dd><p>1D array for the first Y-axis data (left).</p>
</dd>
<dt>y2<span class="classifier">array_like</span></dt><dd><p>1D array for the second Y-axis data (right).</p>
</dd>
<dt>xlab<span class="classifier">str</span></dt><dd><p>Label for the X-axis.</p>
</dd>
<dt>ylab1<span class="classifier">str</span></dt><dd><p>Label for the left Y-axis.</p>
</dd>
<dt>ylab2<span class="classifier">str</span></dt><dd><p>Label for the right Y-axis.</p>
</dd>
<dt>col1<span class="classifier">str</span></dt><dd><p>Color for the first plot (y1).</p>
</dd>
<dt>col2<span class="classifier">str</span></dt><dd><p>Color for the second plot (y2).</p>
</dd>
</dl>
</section>
<section id="id199">
<h4>Returns<a class="headerlink" href="#id199" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>None</dt><dd><p>The function displays the plot and does not return anything.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlottingTwin_SpanSelector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xlab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ylab1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ylab2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">col1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">col2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">saveplt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Plotting.html#Plotting.PlottingTwin_SpanSelector"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Plot two signals with twin Y-axes and a horizontal span selector.</p>
<p>This function creates a plot with two Y-axes (left and right), allowing visualization
of two datasets <cite>y1</cite> and <cite>y2</cite> against a common X-axis <cite>x</cite>, each with its own scale.
A span selector tool is included to highlight and annotate a selected horizontal region.</p>
<section id="id200">
<h4>Parameters<a class="headerlink" href="#id200" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>x<span class="classifier">array_like</span></dt><dd><p>1D array representing the X-axis data.</p>
</dd>
<dt>y1<span class="classifier">array_like</span></dt><dd><p>1D array for the primary Y-axis (left).</p>
</dd>
<dt>y2<span class="classifier">array_like</span></dt><dd><p>1D array for the secondary Y-axis (right).</p>
</dd>
<dt>xlab<span class="classifier">str</span></dt><dd><p>Label for the X-axis.</p>
</dd>
<dt>ylab1<span class="classifier">str</span></dt><dd><p>Label for the left Y-axis (corresponding to <cite>y1</cite>).</p>
</dd>
<dt>ylab2<span class="classifier">str</span></dt><dd><p>Label for the right Y-axis (corresponding to <cite>y2</cite>).</p>
</dd>
<dt>col1<span class="classifier">str</span></dt><dd><p>Line color for <cite>y1</cite>.</p>
</dd>
<dt>col2<span class="classifier">str</span></dt><dd><p>Line color for <cite>y2</cite>.</p>
</dd>
</dl>
</section>
<section id="id201">
<h4>Returns<a class="headerlink" href="#id201" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>tuple</dt><dd><p>(fig, span_selector), where <cite>fig</cite> is the matplotlib Figure object, and
<cite>span_selector</cite> is the interactive selector used to highlight a region on the plot.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Plotting_SpanSelector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xlab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ylab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">col</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">saveplt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Plotting.html#Plotting.Plotting_SpanSelector"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Plot signal with span selector for interactive region selection.</p>
<p>This method plots a signal and adds a horizontal span selector tool
to interactively select a region of the plot. It also displays vertical
lines marking the selection range and annotates the span width.</p>
<section id="id202">
<h4>Parameters<a class="headerlink" href="#id202" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>x<span class="classifier">array_like</span></dt><dd><p>1D array representing the X-axis data.</p>
</dd>
<dt>y<span class="classifier">array_like</span></dt><dd><p>1D array representing the Y-axis data.</p>
</dd>
<dt>xlab<span class="classifier">str</span></dt><dd><p>Label for the X-axis.</p>
</dd>
<dt>ylab<span class="classifier">str</span></dt><dd><p>Label for the Y-axis.</p>
</dd>
<dt>col<span class="classifier">str</span></dt><dd><p>Color code or name for the plot line.</p>
</dd>
</dl>
</section>
<section id="id203">
<h4>Returns<a class="headerlink" href="#id203" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>fig<span class="classifier">matplotlib.figure.Figure</span></dt><dd><p>The matplotlib figure object.</p>
</dd>
<dt>span_selector<span class="classifier">matplotlib.widgets.SpanSelector</span></dt><dd><p>The span selector widget object for interaction.</p>
</dd>
</dl>
</section>
</dd></dl>

</dd></dl>

</section>
</section>
<section id="probability-density-functions-module">
<h2>Probability Density Functions Module<a class="headerlink" href="#probability-density-functions-module" title="Link to this heading"></a></h2>
<section id="probabilitydensityfunctions">
<h3><code class="xref py py-mod docutils literal notranslate"><span class="pre">ProbabilityDensityFunctions</span></code><a class="headerlink" href="#probabilitydensityfunctions" title="Link to this heading"></a></h3>
<p>PyOR - Python On Resonance</p>
<dl>
<dt>Author:</dt><dd><p>Vineeth Francis Thalakottoor Jose Chacko</p>
</dd>
<dt>Email:</dt><dd><p><a class="reference external" href="mailto:vineethfrancis&#46;physics&#37;&#52;&#48;gmail&#46;com">vineethfrancis<span>&#46;</span>physics<span>&#64;</span>gmail<span>&#46;</span>com</a></p>
</dd>
<dt>Description:</dt><dd><p>This module provides probability density functions (PDFs) for use in 
magnetic resonance simulations and statistical modeling within PyOR.</p>
<p>Functions include Gaussian distributions, Lorentzian distributions, 
and custom probability models relevant for signal analysis and noise modeling.</p>
</dd>
</dl>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PDFgaussian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">std</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mean</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="reference internal" href="_modules/Source_Doc/PyOR_ProbabilityDensityFunctions.html#PDFgaussian"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute the normalized Gaussian (normal) probability density function.</p>
<section id="id204">
<h4>Parameters<a class="headerlink" href="#id204" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>x<span class="classifier">np.ndarray</span></dt><dd><p>Array of input values (the variable over which the Gaussian is evaluated).</p>
</dd>
<dt>std<span class="classifier">float</span></dt><dd><p>Standard deviation of the Gaussian distribution.</p>
</dd>
<dt>mean<span class="classifier">float</span></dt><dd><p>Mean (center) of the Gaussian distribution.</p>
</dd>
</dl>
</section>
<section id="id205">
<h4>Returns<a class="headerlink" href="#id205" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>np.ndarray</dt><dd><p>The normalized Gaussian probability density values corresponding to <cite>x</cite>.</p>
</dd>
</dl>
</section>
<section id="id206">
<h4>Notes<a class="headerlink" href="#id206" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>The Gaussian function is defined as:</dt><dd><p>PDF(x) = (1 / sqrt(2πσ²)) * exp(- (x - μ)² / (2σ²))</p>
</dd>
</dl>
<p>The output is normalized such that the sum of the returned values equals 1.
This is useful for discrete approximations of continuous distributions.</p>
</section>
</dd></dl>

</section>
</section>
<section id="quadrupole-moment-module">
<h2>Quadrupole Moment Module<a class="headerlink" href="#quadrupole-moment-module" title="Link to this heading"></a></h2>
<section id="quadrupolemoment">
<h3><code class="xref py py-mod docutils literal notranslate"><span class="pre">QuadrupoleMoment</span></code><a class="headerlink" href="#quadrupolemoment" title="Link to this heading"></a></h3>
<p>PyOR - Python On Resonance</p>
<dl>
<dt>Author:</dt><dd><p>Vineeth Francis Thalakottoor Jose Chacko</p>
</dd>
<dt>Email:</dt><dd><p><a class="reference external" href="mailto:vineethfrancis&#46;physics&#37;&#52;&#48;gmail&#46;com">vineethfrancis<span>&#46;</span>physics<span>&#64;</span>gmail<span>&#46;</span>com</a></p>
</dd>
<dt>Description:</dt><dd><p>This module provides quadrupole moment (Q) values for the electron and 
various nuclei relevant to magnetic resonance simulations.</p>
<p>The quadrupole moment is important for modeling quadrupolar interactions 
in NMR and EPR experiments, especially for nuclei with spin &gt; 1/2.</p>
</dd>
</dl>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">quadrupole</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuadrupoleMoment.html#quadrupole"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Returns the nuclear electric quadrupole moment of a specified particle.</p>
<p>The nuclear quadrupole moment is a measure of the non-spherical distribution 
of electric charge within a nucleus. It plays a critical role in quadrupolar 
interactions observed in NMR and other spectroscopic techniques, especially 
for nuclei with spin quantum number I ≥ 1.</p>
<section id="id207">
<h4>Parameters:<a class="headerlink" href="#id207" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>value<span class="classifier">str</span></dt><dd><dl class="simple">
<dt>Symbol representing the particle. Common examples include:</dt><dd><ul class="simple">
<li><p>“E”   : Electron</p></li>
<li><p>“H1”  : Proton (Hydrogen-1)</p></li>
<li><p>“H2”  : Deuterium (Hydrogen-2)</p></li>
<li><p>“C13” : Carbon-13</p></li>
<li><p>“N14” : Nitrogen-14</p></li>
<li><p>“N15” : Nitrogen-15</p></li>
<li><p>“O17” : Oxygen-17</p></li>
<li><p>“F19” : Fluorine-19</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
</section>
<section id="id208">
<h4>Returns:<a class="headerlink" href="#id208" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>float</dt><dd><p>Nuclear electric quadrupole moment (fm²).</p>
</dd>
</dl>
</section>
<section id="id209">
<h4>Raises:<a class="headerlink" href="#id209" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>AssertionError</dt><dd><p>If the particle symbol is not found in the predefined <cite>QUADRUPOLE</cite> dictionary.
Users can extend the dictionary by adding values manually as needed.</p>
</dd>
</dl>
</section>
<section id="id210">
<h4>Example:<a class="headerlink" href="#id210" title="Link to this heading"></a></h4>
<p>quadrupole(“H2”)
0.285783</p>
<p>quadrupole(“N14”)
2.044</p>
</section>
<section id="id211">
<h4>Reference:<a class="headerlink" href="#id211" title="Link to this heading"></a></h4>
<p>1. Harris, R. K., Becker, E. D., de Menezes, S. M. C., Goodfellow, R., &amp; Granger, P. (2001).  
NMR nomenclature. Nuclear spin properties and conventions for chemical shifts (IUPAC Recommendations 2001).  
<em>Pure and Applied Chemistry</em>, 73(11), 1795–1818.  
DOI: <a class="reference external" href="https://doi.org/10.1351/pac200173111795">https://doi.org/10.1351/pac200173111795</a></p>
<ol class="arabic simple" start="2">
<li><p>Solid State NMR, Principles, Methods, and Applications,  Klaus Müller and Marco Geppi</p></li>
</ol>
</section>
</dd></dl>

</section>
</section>
<section id="quantum-library-module">
<h2>Quantum Library Module<a class="headerlink" href="#quantum-library-module" title="Link to this heading"></a></h2>
<section id="quantumlibrary">
<h3><code class="xref py py-mod docutils literal notranslate"><span class="pre">QuantumLibrary</span></code><a class="headerlink" href="#quantumlibrary" title="Link to this heading"></a></h3>
<p>PyOR - Python On Resonance</p>
<dl>
<dt>Author:</dt><dd><p>Vineeth Francis Thalakottoor Jose Chacko</p>
</dd>
<dt>Email:</dt><dd><p><a class="reference external" href="mailto:vineethfrancis&#46;physics&#37;&#52;&#48;gmail&#46;com">vineethfrancis<span>&#46;</span>physics<span>&#64;</span>gmail<span>&#46;</span>com</a></p>
</dd>
<dt>Description:</dt><dd><p>This module defines the <cite>QuantumLibrary</cite> class, which provides a collection 
of quantum operations and tools for quantum mechanical systems.</p>
<p>The <cite>QuantumLibrary</cite> class includes methods for basis construction, tensor operations, 
commutator evaluation, eigenvalue analysis, partial trace computations, and more, 
supporting simulations in magnetic resonance and general quantum mechanics.</p>
</dd>
</dl>
<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">QuantumLibrary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">class_QS</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumLibrary.html#QuantumLibrary"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AntiCommutationSuperoperator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="Source_Doc.html#Source_Doc.PyOR_QuantumObject.QunObj" title="Source_Doc.PyOR_QuantumObject.QunObj"><span class="pre">QunObj</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="Source_Doc.html#Source_Doc.PyOR_QuantumObject.QunObj" title="Source_Doc.PyOR_QuantumObject.QunObj"><span class="pre">QunObj</span></a></span></span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumLibrary.html#QuantumLibrary.AntiCommutationSuperoperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Create the anti-commutation superoperator {X, ⋅} as a matrix acting on vectorized density matrices.</p>
<section id="id212">
<h4>Parameters<a class="headerlink" href="#id212" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>X<span class="classifier">QunObj</span></dt><dd><p>Operator to construct anti-commutator superoperator from.</p>
</dd>
</dl>
</section>
<section id="id213">
<h4>Returns<a class="headerlink" href="#id213" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>QunObj</dt><dd><p>Anti-commutation superoperator.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AntiCommutator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="Source_Doc.html#Source_Doc.PyOR_QuantumObject.QunObj" title="Source_Doc.PyOR_QuantumObject.QunObj"><span class="pre">QunObj</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="Source_Doc.html#Source_Doc.PyOR_QuantumObject.QunObj" title="Source_Doc.PyOR_QuantumObject.QunObj"><span class="pre">QunObj</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="Source_Doc.html#Source_Doc.PyOR_QuantumObject.QunObj" title="Source_Doc.PyOR_QuantumObject.QunObj"><span class="pre">QunObj</span></a></span></span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumLibrary.html#QuantumLibrary.AntiCommutator"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute the anticommutator {A, B} = AB + BA.</p>
<section id="id214">
<h4>Parameters<a class="headerlink" href="#id214" title="Link to this heading"></a></h4>
<p>A, B : QunObj</p>
</section>
<section id="id215">
<h4>Returns<a class="headerlink" href="#id215" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>QunObj</dt><dd><p>Anticommutator matrix.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Basis_Bra</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">PrintDefault</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumLibrary.html#QuantumLibrary.Basis_Bra"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Generate a bra basis vector ⟨i| of dimension <cite>dim</cite>.</p>
<section id="id216">
<h4>Parameters<a class="headerlink" href="#id216" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>dim<span class="classifier">int</span></dt><dd><p>Dimension of Hilbert space.</p>
</dd>
<dt>index<span class="classifier">int</span></dt><dd><p>Index of the basis vector to set to 1.</p>
</dd>
<dt>PrintDefault<span class="classifier">bool, optional</span></dt><dd><p>Whether to print matrix type info (default is False).</p>
</dd>
</dl>
</section>
<section id="id217">
<h4>Returns<a class="headerlink" href="#id217" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>QunObj</dt><dd><p>Bra vector as a QunObj.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Basis_Ket</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">PrintDefault</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumLibrary.html#QuantumLibrary.Basis_Ket"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Generate a ket basis vector <cite>|i⟩</cite> of dimension <cite>dim</cite>.</p>
<section id="id218">
<h4>Parameters<a class="headerlink" href="#id218" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>dim<span class="classifier">int</span></dt><dd><p>Dimension of Hilbert space.</p>
</dd>
<dt>index<span class="classifier">int</span></dt><dd><p>Index of the basis vector to set to 1.</p>
</dd>
<dt>PrintDefault<span class="classifier">bool, optional</span></dt><dd><p>Whether to print matrix type info (default is False).</p>
</dd>
</dl>
</section>
<section id="id219">
<h4>Returns<a class="headerlink" href="#id219" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>QunObj</dt><dd><p>Ket vector as a QunObj.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Bloch_Vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumLibrary.html#QuantumLibrary.Bloch_Vector"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Generate a qubit state vector <cite>|ψ⟩</cite> on the Bloch sphere.</p>
<section id="id220">
<h4>Parameters<a class="headerlink" href="#id220" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>theta<span class="classifier">float</span></dt><dd><p>Polar angle in degrees.</p>
</dd>
<dt>phi<span class="classifier">float</span></dt><dd><p>Azimuthal angle in degrees.</p>
</dd>
</dl>
</section>
<section id="id221">
<h4>Returns<a class="headerlink" href="#id221" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>QunObj</dt><dd><p>Bloch state vector as a QunObj.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BlockExtract</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Matrix</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="Source_Doc.html#Source_Doc.PyOR_QuantumObject.QunObj" title="Source_Doc.PyOR_QuantumObject.QunObj"><span class="pre">QunObj</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_sizes</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="Source_Doc.html#Source_Doc.PyOR_QuantumObject.QunObj" title="Source_Doc.PyOR_QuantumObject.QunObj"><span class="pre">QunObj</span></a></span></span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumLibrary.html#QuantumLibrary.BlockExtract"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Extract a specific block from a block-diagonal matrix or ket.</p>
<section id="id222">
<h4>Parameters<a class="headerlink" href="#id222" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>Matrix<span class="classifier">QunObj</span></dt><dd><p>Input QunObj instance (operator or ket).</p>
</dd>
<dt>block_index<span class="classifier">int</span></dt><dd><p>Index of the block to extract.</p>
</dd>
<dt>block_sizes<span class="classifier">list of tuple</span></dt><dd><p>List of (row, col) sizes of each block.</p>
</dd>
</dl>
</section>
<section id="id223">
<h4>Returns<a class="headerlink" href="#id223" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>QunObj</dt><dd><p>Extracted block as operator or ket.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Bracket</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="Source_Doc.html#Source_Doc.PyOR_QuantumObject.QunObj" title="Source_Doc.PyOR_QuantumObject.QunObj"><span class="pre">QunObj</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="Source_Doc.html#Source_Doc.PyOR_QuantumObject.QunObj" title="Source_Doc.PyOR_QuantumObject.QunObj"><span class="pre">QunObj</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="Source_Doc.html#Source_Doc.PyOR_QuantumObject.QunObj" title="Source_Doc.PyOR_QuantumObject.QunObj"><span class="pre">QunObj</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="Source_Doc.html#Source_Doc.PyOR_QuantumObject.QunObj" title="Source_Doc.PyOR_QuantumObject.QunObj"><span class="pre">QunObj</span></a></span></span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumLibrary.html#QuantumLibrary.Bracket"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute the scalar bracket ⟨X|A|Y⟩ = Tr(X† A Y)</p>
<section id="id224">
<h4>Parameters<a class="headerlink" href="#id224" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>X<span class="classifier">QunObj</span></dt><dd><p>First operator or state (conjugated from the left).</p>
</dd>
<dt>A<span class="classifier">QunObj</span></dt><dd><p>Middle operator.</p>
</dd>
<dt>Y<span class="classifier">QunObj</span></dt><dd><p>Final operator or state.</p>
</dd>
</dl>
</section>
<section id="id225">
<h4>Returns<a class="headerlink" href="#id225" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>complex</dt><dd><p>Scalar result of the bracket expression.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CommutationSuperoperator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="Source_Doc.html#Source_Doc.PyOR_QuantumObject.QunObj" title="Source_Doc.PyOR_QuantumObject.QunObj"><span class="pre">QunObj</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="Source_Doc.html#Source_Doc.PyOR_QuantumObject.QunObj" title="Source_Doc.PyOR_QuantumObject.QunObj"><span class="pre">QunObj</span></a></span></span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumLibrary.html#QuantumLibrary.CommutationSuperoperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Create the commutation superoperator [X, ⋅] as a matrix acting on vectorized density matrices.</p>
<section id="id226">
<h4>Parameters<a class="headerlink" href="#id226" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>X<span class="classifier">QunObj</span></dt><dd><p>Operator to construct commutator superoperator from.</p>
</dd>
</dl>
</section>
<section id="id227">
<h4>Returns<a class="headerlink" href="#id227" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>QunObj</dt><dd><p>Commutation superoperator.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Commutator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="Source_Doc.html#Source_Doc.PyOR_QuantumObject.QunObj" title="Source_Doc.PyOR_QuantumObject.QunObj"><span class="pre">QunObj</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="Source_Doc.html#Source_Doc.PyOR_QuantumObject.QunObj" title="Source_Doc.PyOR_QuantumObject.QunObj"><span class="pre">QunObj</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="Source_Doc.html#Source_Doc.PyOR_QuantumObject.QunObj" title="Source_Doc.PyOR_QuantumObject.QunObj"><span class="pre">QunObj</span></a></span></span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumLibrary.html#QuantumLibrary.Commutator"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute the commutator [A, B] = AB - BA.</p>
<section id="id228">
<h4>Parameters<a class="headerlink" href="#id228" title="Link to this heading"></a></h4>
<p>A : QunObj
B : QunObj</p>
</section>
<section id="id229">
<h4>Returns<a class="headerlink" href="#id229" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>QunObj</dt><dd><p>Commutator matrix.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DMToVec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="Source_Doc.html#Source_Doc.PyOR_QuantumObject.QunObj" title="Source_Doc.PyOR_QuantumObject.QunObj"><span class="pre">QunObj</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="Source_Doc.html#Source_Doc.PyOR_QuantumObject.QunObj" title="Source_Doc.PyOR_QuantumObject.QunObj"><span class="pre">QunObj</span></a></span></span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumLibrary.html#QuantumLibrary.DMToVec"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Convert a density matrix to a column vector (vectorization) in Liouville space.</p>
<section id="id230">
<h4>Parameters<a class="headerlink" href="#id230" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>rho<span class="classifier">QunObj</span></dt><dd><p>Density matrix.</p>
</dd>
</dl>
</section>
<section id="id231">
<h4>Returns<a class="headerlink" href="#id231" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>QunObj</dt><dd><p>Vectorized form of the density matrix.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DirectSum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="Source_Doc.html#Source_Doc.PyOR_QuantumObject.QunObj" title="Source_Doc.PyOR_QuantumObject.QunObj"><span class="pre">QunObj</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="Source_Doc.html#Source_Doc.PyOR_QuantumObject.QunObj" title="Source_Doc.PyOR_QuantumObject.QunObj"><span class="pre">QunObj</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="Source_Doc.html#Source_Doc.PyOR_QuantumObject.QunObj" title="Source_Doc.PyOR_QuantumObject.QunObj"><span class="pre">QunObj</span></a></span></span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumLibrary.html#QuantumLibrary.DirectSum"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute the direct sum of two QunObj instances.</p>
<section id="id232">
<h4>Parameters<a class="headerlink" href="#id232" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>A, B<span class="classifier">QunObj</span></dt><dd><p>Quantum operators or states.</p>
</dd>
</dl>
</section>
<section id="id233">
<h4>Returns<a class="headerlink" href="#id233" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>QunObj</dt><dd><p>Direct sum matrix or ket.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DirectSumMultiple</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">matrices</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="Source_Doc.html#Source_Doc.PyOR_QuantumObject.QunObj" title="Source_Doc.PyOR_QuantumObject.QunObj"><span class="pre">QunObj</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="Source_Doc.html#Source_Doc.PyOR_QuantumObject.QunObj" title="Source_Doc.PyOR_QuantumObject.QunObj"><span class="pre">QunObj</span></a></span></span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumLibrary.html#QuantumLibrary.DirectSumMultiple"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute direct sum of multiple quantum operators or kets.</p>
<section id="id234">
<h4>Parameters<a class="headerlink" href="#id234" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>*matrices<span class="classifier">QunObj</span></dt><dd><p>Arbitrary number of QunObj instances.</p>
</dd>
</dl>
</section>
<section id="id235">
<h4>Returns<a class="headerlink" href="#id235" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>QunObj</dt><dd><p>Resulting direct sum.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DoubleCommutationSuperoperator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="Source_Doc.html#Source_Doc.PyOR_QuantumObject.QunObj" title="Source_Doc.PyOR_QuantumObject.QunObj"><span class="pre">QunObj</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="Source_Doc.html#Source_Doc.PyOR_QuantumObject.QunObj" title="Source_Doc.PyOR_QuantumObject.QunObj"><span class="pre">QunObj</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="Source_Doc.html#Source_Doc.PyOR_QuantumObject.QunObj" title="Source_Doc.PyOR_QuantumObject.QunObj"><span class="pre">QunObj</span></a></span></span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumLibrary.html#QuantumLibrary.DoubleCommutationSuperoperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Construct the double commutator superoperator [[X, ⋅], Y].</p>
<section id="id236">
<h4>Parameters<a class="headerlink" href="#id236" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>X<span class="classifier">QunObj</span></dt><dd><p>First operator.</p>
</dd>
<dt>Y<span class="classifier">QunObj</span></dt><dd><p>Second operator.</p>
</dd>
</dl>
</section>
<section id="id237">
<h4>Returns<a class="headerlink" href="#id237" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>QunObj</dt><dd><p>Superoperator representing [[X, ⋅], Y].</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DoubleCommutator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="Source_Doc.html#Source_Doc.PyOR_QuantumObject.QunObj" title="Source_Doc.PyOR_QuantumObject.QunObj"><span class="pre">QunObj</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="Source_Doc.html#Source_Doc.PyOR_QuantumObject.QunObj" title="Source_Doc.PyOR_QuantumObject.QunObj"><span class="pre">QunObj</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="Source_Doc.html#Source_Doc.PyOR_QuantumObject.QunObj" title="Source_Doc.PyOR_QuantumObject.QunObj"><span class="pre">QunObj</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="Source_Doc.html#Source_Doc.PyOR_QuantumObject.QunObj" title="Source_Doc.PyOR_QuantumObject.QunObj"><span class="pre">QunObj</span></a></span></span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumLibrary.html#QuantumLibrary.DoubleCommutator"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute the double commutator [A, [B, ρ]].</p>
<section id="id238">
<h4>Parameters<a class="headerlink" href="#id238" title="Link to this heading"></a></h4>
<p>A, B, rho : QunObj</p>
</section>
<section id="id239">
<h4>Returns<a class="headerlink" href="#id239" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>QunObj</dt><dd><p>Result of [[A, [B, rho]]].</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Eigen</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="Source_Doc.html#Source_Doc.PyOR_QuantumObject.QunObj" title="Source_Doc.PyOR_QuantumObject.QunObj"><span class="pre">QunObj</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumLibrary.html#QuantumLibrary.Eigen"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute eigenvalues and eigenvectors of a quantum operator.</p>
<section id="id240">
<h4>Parameters<a class="headerlink" href="#id240" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>A<span class="classifier">QunObj</span></dt><dd><p>Operator to decompose.</p>
</dd>
</dl>
</section>
<section id="id241">
<h4>Returns<a class="headerlink" href="#id241" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>tuple</dt><dd><p>(eigenvalues, eigenvectors) where:
- eigenvalues: QunObj with shape (1, N) as a row of real parts.
- eigenvectors: QunObj with shape (N, N) containing eigenvectors column-wise.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Eigen_Split</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="Source_Doc.html#Source_Doc.PyOR_QuantumObject.QunObj" title="Source_Doc.PyOR_QuantumObject.QunObj"><span class="pre">QunObj</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumLibrary.html#QuantumLibrary.Eigen_Split"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute eigenvalues and eigenvectors of a quantum operator.
Eigenvectors are returned as separate QunObj columns.</p>
<section id="id242">
<h4>Parameters<a class="headerlink" href="#id242" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>A<span class="classifier">QunObj</span></dt><dd><p>Operator to decompose.</p>
</dd>
</dl>
</section>
<section id="id243">
<h4>Returns<a class="headerlink" href="#id243" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>tuple</dt><dd><p>(eigenvalues, eigenvector_list)
- eigenvalues: QunObj with shape (1, N)
- eigenvector_list: list of QunObj, each column vector (N x 1)</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Identity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumLibrary.html#QuantumLibrary.Identity"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Create an identity matrix.</p>
<section id="id244">
<h4>Parameters<a class="headerlink" href="#id244" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>dim<span class="classifier">int</span></dt><dd><p>Dimension.</p>
</dd>
</dl>
</section>
<section id="id245">
<h4>Returns<a class="headerlink" href="#id245" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>QunObj</dt><dd><p>Identity matrix.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InnerProduct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="Source_Doc.html#Source_Doc.PyOR_QuantumObject.QunObj" title="Source_Doc.PyOR_QuantumObject.QunObj"><span class="pre">QunObj</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="Source_Doc.html#Source_Doc.PyOR_QuantumObject.QunObj" title="Source_Doc.PyOR_QuantumObject.QunObj"><span class="pre">QunObj</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="Source_Doc.html#Source_Doc.PyOR_QuantumObject.QunObj" title="Source_Doc.PyOR_QuantumObject.QunObj"><span class="pre">QunObj</span></a></span></span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumLibrary.html#QuantumLibrary.InnerProduct"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute the inner product ⟨A|B⟩.</p>
<section id="id246">
<h4>Parameters<a class="headerlink" href="#id246" title="Link to this heading"></a></h4>
<p>A : QunObj
B : QunObj</p>
</section>
<section id="id247">
<h4>Returns<a class="headerlink" href="#id247" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>QunObj</dt><dd><p>Scalar inner product as a QunObj.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">OuterProduct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="Source_Doc.html#Source_Doc.PyOR_QuantumObject.QunObj" title="Source_Doc.PyOR_QuantumObject.QunObj"><span class="pre">QunObj</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="Source_Doc.html#Source_Doc.PyOR_QuantumObject.QunObj" title="Source_Doc.PyOR_QuantumObject.QunObj"><span class="pre">QunObj</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="Source_Doc.html#Source_Doc.PyOR_QuantumObject.QunObj" title="Source_Doc.PyOR_QuantumObject.QunObj"><span class="pre">QunObj</span></a></span></span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumLibrary.html#QuantumLibrary.OuterProduct"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute the outer product of two QunObj instances.</p>
<section id="id248">
<h4>Parameters<a class="headerlink" href="#id248" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>A<span class="classifier">QunObj</span></dt><dd><p>Ket vector.</p>
</dd>
<dt>B<span class="classifier">QunObj</span></dt><dd><p>Bra vector.</p>
</dd>
</dl>
</section>
<section id="id249">
<h4>Returns<a class="headerlink" href="#id249" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>QunObj</dt><dd><p>Outer product A ⊗ B† as operator.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PartialTrace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="Source_Doc.html#Source_Doc.PyOR_QuantumObject.QunObj" title="Source_Doc.PyOR_QuantumObject.QunObj"><span class="pre">QunObj</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">keep</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Sdim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="Source_Doc.html#Source_Doc.PyOR_QuantumObject.QunObj" title="Source_Doc.PyOR_QuantumObject.QunObj"><span class="pre">QunObj</span></a></span></span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumLibrary.html#QuantumLibrary.PartialTrace"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute the partial trace over specified subsystems of a density matrix.</p>
<section id="id250">
<h4>Parameters<a class="headerlink" href="#id250" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>rho<span class="classifier">QunObj</span></dt><dd><p>Density matrix.</p>
</dd>
<dt>keep<span class="classifier">list of int</span></dt><dd><p>Indices of subsystems to retain.</p>
</dd>
<dt>Sdim<span class="classifier">list of int, optional</span></dt><dd><p>Dimensions of subsystems (defaults to class_QS.Sdim).</p>
</dd>
</dl>
</section>
<section id="id251">
<h4>Returns<a class="headerlink" href="#id251" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>QunObj</dt><dd><p>Reduced density matrix after tracing out unlisted subsystems.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Purity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="Source_Doc.html#Source_Doc.PyOR_QuantumObject.QunObj" title="Source_Doc.PyOR_QuantumObject.QunObj"><span class="pre">QunObj</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="Source_Doc.html#Source_Doc.PyOR_QuantumObject.QunObj" title="Source_Doc.PyOR_QuantumObject.QunObj"><span class="pre">QunObj</span></a></span></span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumLibrary.html#QuantumLibrary.Purity"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Calculate the purity of a quantum state: Tr(ρ²).</p>
<section id="id252">
<h4>Parameters<a class="headerlink" href="#id252" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>A<span class="classifier">QunObj</span></dt><dd><p>Density matrix.</p>
</dd>
</dl>
</section>
<section id="id253">
<h4>Returns<a class="headerlink" href="#id253" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>QunObj</dt><dd><p>Scalar result of the purity calculation.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SSpinOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">String</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">PrintDefault</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumLibrary.html#QuantumLibrary.SSpinOp"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Construct single spin operators (Sx, Sy, Sz, S+, S-) for a given spin S.</p>
<section id="id254">
<h4>Parameters<a class="headerlink" href="#id254" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>X<span class="classifier">float</span></dt><dd><p>Spin quantum number (e.g., 1/2, 1, 3/2).</p>
</dd>
<dt>String<span class="classifier">str</span></dt><dd><p>Operator type: ‘x’, ‘y’, ‘z’, ‘p’, or ‘m’.</p>
</dd>
<dt>PrintDefault<span class="classifier">bool, optional</span></dt><dd><p>Whether to print matrix type info.</p>
</dd>
</dl>
</section>
<section id="id255">
<h4>Returns<a class="headerlink" href="#id255" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>QunObj</dt><dd><p>Requested spin operator matrix.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TensorProduct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="Source_Doc.html#Source_Doc.PyOR_QuantumObject.QunObj" title="Source_Doc.PyOR_QuantumObject.QunObj"><span class="pre">QunObj</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="Source_Doc.html#Source_Doc.PyOR_QuantumObject.QunObj" title="Source_Doc.PyOR_QuantumObject.QunObj"><span class="pre">QunObj</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="Source_Doc.html#Source_Doc.PyOR_QuantumObject.QunObj" title="Source_Doc.PyOR_QuantumObject.QunObj"><span class="pre">QunObj</span></a></span></span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumLibrary.html#QuantumLibrary.TensorProduct"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute the Kronecker product (tensor product) of two QunObj instances.</p>
<section id="id256">
<h4>Parameters<a class="headerlink" href="#id256" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>A, B<span class="classifier">QunObj</span></dt><dd><p>Quantum operators or states.</p>
</dd>
</dl>
</section>
<section id="id257">
<h4>Returns<a class="headerlink" href="#id257" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>QunObj</dt><dd><p>Tensor product result.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TensorProductMultiple</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">matrices</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="Source_Doc.html#Source_Doc.PyOR_QuantumObject.QunObj" title="Source_Doc.PyOR_QuantumObject.QunObj"><span class="pre">QunObj</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="Source_Doc.html#Source_Doc.PyOR_QuantumObject.QunObj" title="Source_Doc.PyOR_QuantumObject.QunObj"><span class="pre">QunObj</span></a></span></span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumLibrary.html#QuantumLibrary.TensorProductMultiple"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute tensor product of multiple QunObj instances.</p>
<section id="id258">
<h4>Parameters<a class="headerlink" href="#id258" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>*matrices<span class="classifier">QunObj</span></dt><dd><p>Arbitrary number of quantum operators or states.</p>
</dd>
</dl>
</section>
<section id="id259">
<h4>Returns<a class="headerlink" href="#id259" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>QunObj</dt><dd><p>Tensor product of all matrices.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VecToDM</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vec</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="Source_Doc.html#Source_Doc.PyOR_QuantumObject.QunObj" title="Source_Doc.PyOR_QuantumObject.QunObj"><span class="pre">QunObj</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">tuple</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="Source_Doc.html#Source_Doc.PyOR_QuantumObject.QunObj" title="Source_Doc.PyOR_QuantumObject.QunObj"><span class="pre">QunObj</span></a></span></span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumLibrary.html#QuantumLibrary.VecToDM"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Convert a vectorized density matrix back into matrix form.</p>
<section id="id260">
<h4>Parameters<a class="headerlink" href="#id260" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>vec<span class="classifier">QunObj</span></dt><dd><p>Vectorized density matrix.</p>
</dd>
<dt>shape<span class="classifier">tuple</span></dt><dd><p>Shape (rows, cols) of the original density matrix.</p>
</dd>
</dl>
</section>
<section id="id261">
<h4>Returns<a class="headerlink" href="#id261" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>QunObj</dt><dd><p>Reshaped density matrix.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Zeros</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumLibrary.html#QuantumLibrary.Zeros"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Create a zero matrix.</p>
<section id="id262">
<h4>Parameters<a class="headerlink" href="#id262" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>dim<span class="classifier">int</span></dt><dd><p>Dimension.</p>
</dd>
</dl>
</section>
<section id="id263">
<h4>Returns<a class="headerlink" href="#id263" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>QunObj</dt><dd><p>Zero matrix.</p>
</dd>
</dl>
</section>
</dd></dl>

</dd></dl>

</section>
</section>
<section id="quantum-object-module">
<h2>Quantum Object Module<a class="headerlink" href="#quantum-object-module" title="Link to this heading"></a></h2>
<section id="quantumobject">
<h3><code class="xref py py-mod docutils literal notranslate"><span class="pre">QuantumObject</span></code><a class="headerlink" href="#quantumobject" title="Link to this heading"></a></h3>
<p>PyOR - Python On Resonance</p>
<dl>
<dt>Author:</dt><dd><p>Vineeth Francis Thalakottoor Jose Chacko</p>
</dd>
<dt>Email:</dt><dd><p><a class="reference external" href="mailto:vineethfrancis&#46;physics&#37;&#52;&#48;gmail&#46;com">vineethfrancis<span>&#46;</span>physics<span>&#64;</span>gmail<span>&#46;</span>com</a></p>
</dd>
<dt>Description:</dt><dd><p>This module defines the <cite>QunObj</cite> (Quantum Object) class, a flexible object for 
representing quantum states (kets, bras) and operators.</p>
<p>The <cite>QunObj</cite> class supports standard quantum mechanical operations, including 
Hermitian conjugation, tensor products, inner products, outer products, 
expectation value calculations, and more.</p>
</dd>
</dl>
<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">QunObj</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Type=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">DType=&lt;class</span> <span class="pre">'complex'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">PrintDefault=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerence=1e-10</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumObject.html#QunObj"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Adjoint</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumObject.html#QunObj.Adjoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Return the Hermitian conjugate (dagger) of the quantum object.</p>
<section id="id264">
<h4>Returns<a class="headerlink" href="#id264" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>QunObj</dt><dd><p>The conjugate transpose of the object.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">basis_name</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumObject.html#QunObj.Basis"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Perform a basis transformation using a predefined transformation matrix.</p>
<p>For quantum states (type=’ket’): <span class="math notranslate nohighlight">\(|\psi\rangle \rightarrow U|\psi\rangle\)</span>  
For operators (type=’operator’): <span class="math notranslate nohighlight">\(O \rightarrow U^\dagger O U\)</span></p>
<p>Currently supported basis names:
- ‘singlettriplet’ : Transformation to singlet-triplet basis.</p>
<section id="id265">
<h4>Parameters<a class="headerlink" href="#id265" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>basis_name<span class="classifier">str</span></dt><dd><p>Name of the predefined basis.</p>
</dd>
</dl>
</section>
<section id="id266">
<h4>Returns<a class="headerlink" href="#id266" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>QunObj</dt><dd><p>The quantum object in the new basis.</p>
</dd>
</dl>
</section>
<section id="id267">
<h4>Raises<a class="headerlink" href="#id267" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>ValueError</dt><dd><p>If an unsupported basis name is provided or type is unsupported.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BasisChange</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumObject.html#QunObj.BasisChange"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Perform a basis transformation on the quantum object using transformation matrix U.</p>
<p>For quantum states (type=’ket’): <span class="math notranslate nohighlight">\(|\psi\rangle \rightarrow U|\psi\rangle\)</span>  
For operators (type=’operator’): <span class="math notranslate nohighlight">\(O \rightarrow U^\dagger O U\)</span></p>
<section id="id268">
<h4>Parameters<a class="headerlink" href="#id268" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>U<span class="classifier">QunObj</span></dt><dd><p>The unitary transformation matrix.</p>
</dd>
</dl>
</section>
<section id="id269">
<h4>Returns<a class="headerlink" href="#id269" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>QunObj</dt><dd><p>The quantum object expressed in the new basis.</p>
</dd>
</dl>
</section>
<section id="id270">
<h4>Raises<a class="headerlink" href="#id270" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>TypeError</dt><dd><p>If U is not a QunObj.</p>
</dd>
<dt>ValueError</dt><dd><p>If called on an unsupported object type (e.g., ‘bra’).</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Commute</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumObject.html#QunObj.Commute"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Check if two QunObj instances commute.</p>
<section id="id271">
<h4>Parameters<a class="headerlink" href="#id271" title="Link to this heading"></a></h4>
<p>other : QunObj</p>
</section>
<section id="id272">
<h4>Returns<a class="headerlink" href="#id272" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>bool</dt><dd><p>True if commutator is zero, False otherwise.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Conjugate</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumObject.html#QunObj.Conjugate"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Return the complex conjugate of the quantum object.</p>
<section id="id273">
<h4>Returns<a class="headerlink" href="#id273" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>QunObj</dt><dd><p>The complex conjugated quantum object.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Expectation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">operator</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumObject.html#QunObj.Expectation"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute the expectation value of an operator.</p>
<p>For a state <span class="math notranslate nohighlight">\(|\psi\rangle\)</span>: <span class="math notranslate nohighlight">\(\langle \psi | A | \psi \rangle\)</span>  
For a density matrix <span class="math notranslate nohighlight">\(\rho\)</span>: <span class="math notranslate nohighlight">\(\mathrm{Tr}(\rho A)\)</span></p>
<section id="id274">
<h4>Parameters<a class="headerlink" href="#id274" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>operator<span class="classifier">QunObj</span></dt><dd><p>Operator for which to compute the expectation value.</p>
</dd>
</dl>
</section>
<section id="id275">
<h4>Returns<a class="headerlink" href="#id275" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>complex</dt><dd><p>Expectation value.</p>
</dd>
</dl>
</section>
<section id="id276">
<h4>Raises<a class="headerlink" href="#id276" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>TypeError</dt><dd><p>If input is not a QunObj.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Expm</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumObject.html#QunObj.Expm"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute the matrix exponential exp(A).</p>
<section id="id277">
<h4>Returns<a class="headerlink" href="#id277" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>QunObj</dt><dd><p>The matrix exponential of the object.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Hermitian</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumObject.html#QunObj.Hermitian"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Check whether the matrix is Hermitian (A = A†).</p>
<section id="id278">
<h4>Returns<a class="headerlink" href="#id278" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>bool</dt><dd><p>True if Hermitian, False otherwise.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InnerProduct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumObject.html#QunObj.InnerProduct"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Inner product: ⟨ψ|φ⟩ or Tr(A†B).</p>
<section id="id279">
<h4>Parameters<a class="headerlink" href="#id279" title="Link to this heading"></a></h4>
<p>other : QunObj</p>
</section>
<section id="id280">
<h4>Returns<a class="headerlink" href="#id280" title="Link to this heading"></a></h4>
<p>complex</p>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Inverse</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumObject.html#QunObj.Inverse"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute the matrix inverse.</p>
<section id="id281">
<h4>Returns<a class="headerlink" href="#id281" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>QunObj</dt><dd><p>The inverse of the quantum object.</p>
</dd>
</dl>
</section>
<section id="id282">
<h4>Raises<a class="headerlink" href="#id282" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>np.linalg.LinAlgError</dt><dd><p>If the matrix is singular or not square.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Inverse2PI</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumObject.html#QunObj.Inverse2PI"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Divide all elements of the quantum object by 2π.</p>
<p>Useful for converting angular frequency to frequency units.</p>
<section id="id283">
<h4>Returns<a class="headerlink" href="#id283" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>QunObj</dt><dd><p>The scaled object.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">NeumannEntropy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumObject.html#QunObj.NeumannEntropy"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute the Von Neumann entropy S = -Tr(ρ log ρ).</p>
<section id="id284">
<h4>Returns<a class="headerlink" href="#id284" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>float</dt><dd><p>The entropy value.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Norm</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumObject.html#QunObj.Norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute the Frobenius norm of the matrix.</p>
<section id="id285">
<h4>Returns<a class="headerlink" href="#id285" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>float</dt><dd><p>Frobenius norm ||A||_F.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Norm_HZ</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumObject.html#QunObj.Norm_HZ"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute the Frobenius norm scaled by 1 / (2π).</p>
<section id="id286">
<h4>Returns<a class="headerlink" href="#id286" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>float</dt><dd><p>Scaled Frobenius norm.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Normalize</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumObject.html#QunObj.Normalize"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Normalize the quantum state or operator.</p>
<section id="id287">
<h4>Returns<a class="headerlink" href="#id287" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>QunObj</dt><dd><p>Normalized object.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">OuterProduct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumObject.html#QunObj.OuterProduct"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Outer product: <cite>|ψ⟩⟨φ|</cite>.</p>
<section id="id288">
<h4>Parameters<a class="headerlink" href="#id288" title="Link to this heading"></a></h4>
<p>other : QunObj</p>
</section>
<section id="id289">
<h4>Returns<a class="headerlink" href="#id289" title="Link to this heading"></a></h4>
<p>QunObj</p>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Positive</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumObject.html#QunObj.Positive"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Print whether all diagonal elements are non-negative.</p>
<p>Useful for checking if a density matrix is physical.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Purity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumObject.html#QunObj.Purity"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute the purity Tr(ρ²) of a density matrix.</p>
<section id="id290">
<h4>Returns<a class="headerlink" href="#id290" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>float</dt><dd><p>Purity value (1 for pure states).</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Rotate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">theta_rad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operator</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumObject.html#QunObj.Rotate"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Apply a unitary rotation to the quantum object.</p>
<p>For operators:
<span class="math notranslate nohighlight">\(\rho \rightarrow U \rho U^\dagger\)</span> where <span class="math notranslate nohighlight">\(U = \exp(-i \theta A)\)</span></p>
<p>For states:
<span class="math notranslate nohighlight">\(|\psi\rangle \rightarrow U |\psi\rangle\)</span> where <span class="math notranslate nohighlight">\(U = \exp(-i \theta A)\)</span></p>
<section id="id291">
<h4>Parameters<a class="headerlink" href="#id291" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>theta_rad<span class="classifier">float</span></dt><dd><p>Rotation angle in degrees.</p>
</dd>
<dt>operator<span class="classifier">QunObj</span></dt><dd><p>Hermitian operator generating the rotation.</p>
</dd>
</dl>
</section>
<section id="id292">
<h4>Returns<a class="headerlink" href="#id292" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>QunObj</dt><dd><p>Rotated quantum object.</p>
</dd>
</dl>
</section>
<section id="id293">
<h4>Raises<a class="headerlink" href="#id293" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>TypeError</dt><dd><p>If <cite>operator</cite> is not a QunObj.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Round</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">roundto</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumObject.html#QunObj.Round"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Round the entries in the quantum object to a given decimal place.</p>
<section id="id294">
<h4>Parameters<a class="headerlink" href="#id294" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>roundto<span class="classifier">int</span></dt><dd><p>Number of decimal places to round.</p>
</dd>
</dl>
</section>
<section id="id295">
<h4>Returns<a class="headerlink" href="#id295" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>QunObj</dt><dd><p>Rounded object.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TensorProduct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumObject.html#QunObj.TensorProduct"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute tensor product with another QunObj.</p>
<section id="id296">
<h4>Parameters<a class="headerlink" href="#id296" title="Link to this heading"></a></h4>
<p>other : QunObj</p>
</section>
<section id="id297">
<h4>Returns<a class="headerlink" href="#id297" title="Link to this heading"></a></h4>
<p>QunObj</p>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Tolarence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tol</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumObject.html#QunObj.Tolarence"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Zero out all elements with magnitude below the specified tolerance.</p>
<section id="id298">
<h4>Parameters<a class="headerlink" href="#id298" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>tol<span class="classifier">float</span></dt><dd><p>Tolerance value.</p>
</dd>
</dl>
</section>
<section id="id299">
<h4>Returns<a class="headerlink" href="#id299" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>QunObj</dt><dd><p>Cleaned object with small elements set to zero.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Trace</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumObject.html#QunObj.Trace"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute the trace of the matrix.</p>
<section id="id300">
<h4>Returns<a class="headerlink" href="#id300" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>complex</dt><dd><p>The trace value.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Tranpose</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumObject.html#QunObj.Tranpose"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Return the transpose of the quantum object (without complex conjugation).</p>
<section id="id301">
<h4>Returns<a class="headerlink" href="#id301" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>QunObj</dt><dd><p>The transposed quantum object.</p>
</dd>
</dl>
</section>
</dd></dl>

</dd></dl>

</section>
</section>
<section id="quantum-system-module">
<h2>Quantum System Module<a class="headerlink" href="#quantum-system-module" title="Link to this heading"></a></h2>
<section id="quantumsystem">
<h3><code class="xref py py-mod docutils literal notranslate"><span class="pre">QuantumSystem</span></code><a class="headerlink" href="#quantumsystem" title="Link to this heading"></a></h3>
<p>PyOR - Python On Resonance</p>
<dl>
<dt>Author:</dt><dd><p>Vineeth Francis Thalakottoor Jose Chacko</p>
</dd>
<dt>Email:</dt><dd><p><a class="reference external" href="mailto:vineethfrancis&#46;physics&#37;&#52;&#48;gmail&#46;com">vineethfrancis<span>&#46;</span>physics<span>&#64;</span>gmail<span>&#46;</span>com</a></p>
</dd>
<dt>Description:</dt><dd><p>This module defines the <cite>QuantumSystem</cite> class, which represents composite 
quantum systems consisting of multiple interacting particles or subsystems.</p>
<p>The <cite>QuantumSystem</cite> class provides tools for managing the total system Hilbert space, 
constructing composite states and operators, and simulating evolution under 
system-wide Hamiltonians.</p>
</dd>
</dl>
<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">QuantumSystem</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">SpinList</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">PrintDefault</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumSystem.html#QuantumSystem"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>QuantumSystem: Central class in PyOR for defining and manipulating multi-spin quantum systems.</p>
<p>This class sets up the quantum system based on a list of spins, initializes physical and
numerical parameters, manages spin operators, relaxation mechanisms, acquisition settings,
plotting preferences, and state evolution.</p>
<section id="id302">
<h4>Parameters<a class="headerlink" href="#id302" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>SpinList<span class="classifier">dict</span></dt><dd><p>Dictionary mapping spin labels to spin types (e.g., {‘I’: ‘1H’, ‘S’: ‘13C’})</p>
</dd>
<dt>PrintDefault<span class="classifier">bool, optional</span></dt><dd><p>If True, prints all default system settings and parameters.</p>
</dd>
</dl>
</section>
<section id="attributes">
<h4>Attributes<a class="headerlink" href="#attributes" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>SpinList<span class="classifier">dict</span></dt><dd><p>User-defined spin system.</p>
</dd>
<dt>SpinDic<span class="classifier">list</span></dt><dd><p>List of spin keys from the dictionary.</p>
</dd>
<dt>SpinName<span class="classifier">np.array</span></dt><dd><p>List of spin names (e.g., [‘1H’, ‘13C’]).</p>
</dd>
<dt>SpinIndex<span class="classifier">dict</span></dt><dd><p>Dictionary mapping spin label to index.</p>
</dd>
<dt>slist<span class="classifier">np.array</span></dt><dd><p>List of spin quantum numbers.</p>
</dd>
<dt>Sdim<span class="classifier">np.array</span></dt><dd><p>Dimensions of each individual spin Hilbert space.</p>
</dd>
<dt>Vdim<span class="classifier">int</span></dt><dd><p>Dimension of the total Hilbert space.</p>
</dd>
<dt>Ldim<span class="classifier">int</span></dt><dd><p>Dimension of the Liouville space (Vdim^2).</p>
</dd>
<dt>hbarEQ1<span class="classifier">bool</span></dt><dd><p>Toggle to treat ℏ = 1 in Hamiltonians.</p>
</dd>
<dt>MatrixTolarence<span class="classifier">float</span></dt><dd><p>Elements smaller than this are considered zero in matrices.</p>
</dd>
<dt>Gamma<span class="classifier">list</span></dt><dd><p>Gyromagnetic ratios of spins.</p>
</dd>
<dt>B0<span class="classifier">float</span></dt><dd><p>Static magnetic field (Tesla).</p>
</dd>
<dt>OFFSET, OMEGA_RF<span class="classifier">dict</span></dt><dd><p>Offset and rotating frame frequencies.</p>
</dd>
<dt>Jlist<span class="classifier">np.ndarray</span></dt><dd><p>J-coupling matrix.</p>
</dd>
<dt>Dipole_Pairs<span class="classifier">list</span></dt><dd><p>List of dipolar-coupled spin index pairs.</p>
</dd>
<dt>Various attributes…</dt><dd><p>Many more attributes initialized for relaxation, plotting, acquisition, etc.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Adjoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumSystem.html#QuantumSystem.Adjoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute the adjoint (Hermitian conjugate) of an operator.</p>
<section id="id303">
<h5>Parameters<a class="headerlink" href="#id303" title="Link to this heading"></a></h5>
<dl class="simple">
<dt>A<span class="classifier">ndarray</span></dt><dd><p>Operator or state vector.</p>
</dd>
</dl>
</section>
<section id="id304">
<h5>Returns<a class="headerlink" href="#id304" title="Link to this heading"></a></h5>
<dl class="simple">
<dt>ndarray</dt><dd><p>Hermitian conjugate of the input.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BasisChange_Operator_Local</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">O</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumSystem.html#QuantumSystem.BasisChange_Operator_Local"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Transform an operator using the given transformation matrix.</p>
<section id="id305">
<h5>Parameters<a class="headerlink" href="#id305" title="Link to this heading"></a></h5>
<dl class="simple">
<dt>O<span class="classifier">np.ndarray</span></dt><dd><p>Operator in the original basis.</p>
</dd>
<dt>U<span class="classifier">QunObj</span></dt><dd><p>Transformation matrix as a QunObj.</p>
</dd>
</dl>
</section>
<section id="id306">
<h5>Returns<a class="headerlink" href="#id306" title="Link to this heading"></a></h5>
<dl class="simple">
<dt>np.ndarray</dt><dd><p>Operator in the new basis.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BasisChange_SpinOperators_Local</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Sop</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumSystem.html#QuantumSystem.BasisChange_SpinOperators_Local"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Transform an array of spin operators using a transformation matrix.</p>
<section id="id307">
<h5>Parameters<a class="headerlink" href="#id307" title="Link to this heading"></a></h5>
<dl class="simple">
<dt>Sop<span class="classifier">np.ndarray</span></dt><dd><p>Array of shape (N, dim, dim) containing spin operators (e.g., [Sx, Sy, Sz]).</p>
</dd>
<dt>U<span class="classifier">QunObj</span></dt><dd><p>Transformation matrix as a QunObj.</p>
</dd>
</dl>
</section>
<section id="id308">
<h5>Returns<a class="headerlink" href="#id308" title="Link to this heading"></a></h5>
<dl class="simple">
<dt>np.ndarray</dt><dd><p>Transformed spin operators as an array of shape (N, dim, dim).</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Bracket</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="Source_Doc.html#Source_Doc.PyOR_QuantumObject.QunObj" title="Source_Doc.PyOR_QuantumObject.QunObj"><span class="pre">QunObj</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="Source_Doc.html#Source_Doc.PyOR_QuantumObject.QunObj" title="Source_Doc.PyOR_QuantumObject.QunObj"><span class="pre">QunObj</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="Source_Doc.html#Source_Doc.PyOR_QuantumObject.QunObj" title="Source_Doc.PyOR_QuantumObject.QunObj"><span class="pre">QunObj</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumSystem.html#QuantumSystem.Bracket"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute the bracket ⟨X|A|Y⟩ / ⟨X|Y⟩.</p>
<p>Used for angular momentum evaluation.</p>
<section id="id309">
<h5>Parameters<a class="headerlink" href="#id309" title="Link to this heading"></a></h5>
<dl class="simple">
<dt>X, A, Y<span class="classifier">QunObj</span></dt><dd><p>Operators and state vectors.</p>
</dd>
</dl>
</section>
<section id="id310">
<h5>Returns<a class="headerlink" href="#id310" title="Link to this heading"></a></h5>
<dl class="simple">
<dt>float</dt><dd><p>Result of ⟨X|A|Y⟩ normalized by ⟨X|Y⟩.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Convert_EnergyTOFreqUnits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumSystem.html#QuantumSystem.Convert_EnergyTOFreqUnits"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Convert Hamiltonian from energy units (Joules) to angular frequency units (rad/s).</p>
<section id="id311">
<h5>Parameters<a class="headerlink" href="#id311" title="Link to this heading"></a></h5>
<dl class="simple">
<dt>H<span class="classifier">float or ndarray</span></dt><dd><p>Hamiltonian in energy units.</p>
</dd>
</dl>
</section>
<section id="id312">
<h5>Returns<a class="headerlink" href="#id312" title="Link to this heading"></a></h5>
<dl class="simple">
<dt>float or ndarray</dt><dd><p>Hamiltonian in angular frequency units.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Convert_FreqUnitsTOEnergy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumSystem.html#QuantumSystem.Convert_FreqUnitsTOEnergy"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Convert Hamiltonian from angular frequency units to energy units (Joules).</p>
<section id="id313">
<h5>Parameters<a class="headerlink" href="#id313" title="Link to this heading"></a></h5>
<dl class="simple">
<dt>H<span class="classifier">float or ndarray</span></dt><dd><p>Hamiltonian in angular frequency units.</p>
</dd>
</dl>
</section>
<section id="id314">
<h5>Returns<a class="headerlink" href="#id314" title="Link to this heading"></a></h5>
<dl class="simple">
<dt>float or ndarray</dt><dd><p>Hamiltonian in energy units.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Eigen</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="Source_Doc.html#Source_Doc.PyOR_QuantumObject.QunObj" title="Source_Doc.PyOR_QuantumObject.QunObj"><span class="pre">QunObj</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumSystem.html#QuantumSystem.Eigen"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute eigenvalues and eigenvectors of a quantum object.</p>
<section id="id315">
<h5>Parameters<a class="headerlink" href="#id315" title="Link to this heading"></a></h5>
<dl class="simple">
<dt>A<span class="classifier">QunObj</span></dt><dd><p>The quantum object (operator) to decompose.</p>
</dd>
</dl>
</section>
<section id="id316">
<h5>Returns<a class="headerlink" href="#id316" title="Link to this heading"></a></h5>
<dl class="simple">
<dt>tuple</dt><dd><p>(eigenvalues as ndarray, eigenvectors as QunObj)</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Eigen_Split</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="Source_Doc.html#Source_Doc.PyOR_QuantumObject.QunObj" title="Source_Doc.PyOR_QuantumObject.QunObj"><span class="pre">QunObj</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumSystem.html#QuantumSystem.Eigen_Split"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute eigenvalues and return eigenvectors as a list of QunObj.</p>
<section id="id317">
<h5>Parameters<a class="headerlink" href="#id317" title="Link to this heading"></a></h5>
<dl class="simple">
<dt>A<span class="classifier">QunObj</span></dt><dd><p>Quantum operator.</p>
</dd>
</dl>
</section>
<section id="id318">
<h5>Returns<a class="headerlink" href="#id318" title="Link to this heading"></a></h5>
<dl class="simple">
<dt>tuple</dt><dd><p>(eigenvalues as ndarray, eigenvectors as list of QunObj column vectors)</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">HztoPPM</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">freq_sample</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumSystem.html#QuantumSystem.HztoPPM"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Convert frequency from Hz to PPM.</p>
<section id="id319">
<h5>Parameters<a class="headerlink" href="#id319" title="Link to this heading"></a></h5>
<dl class="simple">
<dt>freq_sample<span class="classifier">float</span></dt><dd><p>Frequency in Hz.</p>
</dd>
<dt>ref<span class="classifier">float</span></dt><dd><p>Reference frequency in Hz.</p>
</dd>
</dl>
</section>
<section id="id320">
<h5>Returns<a class="headerlink" href="#id320" title="Link to this heading"></a></h5>
<dl class="simple">
<dt>float</dt><dd><p>Chemical shift in ppm.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">IndividualThermalDensityMatrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumSystem.html#QuantumSystem.IndividualThermalDensityMatrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Initialize and assign the individual spin thermal density matrices.</p>
<p>For each spin, constructs the density matrix using Boltzmann distribution
in the Zeeman basis and stores it as an attribute.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Initialize</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumSystem.html#QuantumSystem.Initialize"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Initialize the quantum system:
- Compute spin operators (Sx, Sy, Sz, etc.)
- Populate particle-related properties (gamma, quadrupole, etc.)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JcoupleValue</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumSystem.html#QuantumSystem.JcoupleValue"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Set scalar J coupling constant between two spins.</p>
<section id="id321">
<h5>Parameters<a class="headerlink" href="#id321" title="Link to this heading"></a></h5>
<dl class="simple">
<dt>x<span class="classifier">str</span></dt><dd><p>Label of spin 1.</p>
</dd>
<dt>y<span class="classifier">str</span></dt><dd><p>Label of spin 2.</p>
</dd>
<dt>value<span class="classifier">float</span></dt><dd><p>J coupling constant in Hz.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MagQnuSingle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumSystem.html#QuantumSystem.MagQnuSingle"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Return magnetic quantum number values for an individual spin.</p>
<section id="id322">
<h5>Parameters<a class="headerlink" href="#id322" title="Link to this heading"></a></h5>
<dl class="simple">
<dt>X<span class="classifier">float</span></dt><dd><p>Spin quantum number.</p>
</dd>
</dl>
</section>
<section id="id323">
<h5>Returns<a class="headerlink" href="#id323" title="Link to this heading"></a></h5>
<dl class="simple">
<dt>np.ndarray</dt><dd><p>Array of magnetic quantum numbers: [X, X-1, …, -X].</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MagQnuSystem</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumSystem.html#QuantumSystem.MagQnuSystem"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Return total magnetic quantum numbers (Sz expectation) for each Zeeman state.</p>
<section id="id324">
<h5>Returns<a class="headerlink" href="#id324" title="Link to this heading"></a></h5>
<dl class="simple">
<dt>np.ndarray</dt><dd><p>Diagonal values of total Sz.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PPMtoHz</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ppm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumSystem.html#QuantumSystem.PPMtoHz"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Convert chemical shift from PPM to Hz.</p>
<section id="id325">
<h5>Parameters<a class="headerlink" href="#id325" title="Link to this heading"></a></h5>
<dl class="simple">
<dt>ppm<span class="classifier">float</span></dt><dd><p>Chemical shift in ppm.</p>
</dd>
<dt>ref<span class="classifier">float</span></dt><dd><p>Reference frequency in Hz.</p>
</dd>
</dl>
</section>
<section id="id326">
<h5>Returns<a class="headerlink" href="#id326" title="Link to this heading"></a></h5>
<dl class="simple">
<dt>float</dt><dd><p>Frequency in Hz.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ParticleParameters</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumSystem.html#QuantumSystem.ParticleParameters"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Initialize particle properties for each spin.</p>
<p>Automatically retrieves constants from PyOR_Particle.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PyOR_Version</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumSystem.html#QuantumSystem.PyOR_Version"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Print version info for PyOR and its dependencies.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpinOperator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">PrintDefault</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumSystem.html#QuantumSystem.SpinOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Generate spin operators Sx, Sy, Sz, Sp, Sm for all spins in the system.</p>
<p>Also assigns:
- <cite>self.Sx_</cite>, <cite>self.Sy_</cite>, <cite>self.Sz_</cite>, <cite>self.Sp_</cite>, <cite>self.Sm_</cite> : ndarray
- self.Jsquared (total angular momentum operator): QunObj
- Individual spin operators as class attributes (e.g., Ix, Iy, Iz, etc.)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpinOperator_SpinQunatulNumber_List</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">SpinQNlist</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumSystem.html#QuantumSystem.SpinOperator_SpinQunatulNumber_List"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Generate full-system spin operators from a list of spin quantum numbers.</p>
<section id="id327">
<h5>Parameters<a class="headerlink" href="#id327" title="Link to this heading"></a></h5>
<dl class="simple">
<dt>SpinQNlist<span class="classifier">list of float</span></dt><dd><p>List of spin quantum numbers [s1, s2, …, sn].</p>
</dd>
</dl>
</section>
<section id="id328">
<h5>Returns<a class="headerlink" href="#id328" title="Link to this heading"></a></h5>
<dl class="simple">
<dt>tuple of np.ndarray</dt><dd><p>Arrays of shape (n, dim, dim) for Sx, Sy, and Sz.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpinOperator_Sub</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">PrintDefault</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumSystem.html#QuantumSystem.SpinOperator_Sub"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Generate subsystem spin operators for each individual spin.</p>
<p>Stores operators with suffix <cite>_sub</cite> for each spin label.
Example: Ix_sub, Iy_sub, Iz_sub, Ip_sub, Im_sub, Iid_sub</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpinOperatorsSingleSpin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumSystem.html#QuantumSystem.SpinOperatorsSingleSpin"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Generate spin operators (Sx, Sy, Sz) for a single spin quantum number.</p>
<section id="id329">
<h5>Parameters<a class="headerlink" href="#id329" title="Link to this heading"></a></h5>
<dl class="simple">
<dt>X<span class="classifier">float</span></dt><dd><p>Spin quantum number (e.g., 1/2, 1, 3/2).</p>
</dd>
</dl>
</section>
<section id="id330">
<h5>Returns<a class="headerlink" href="#id330" title="Link to this heading"></a></h5>
<dl class="simple">
<dt>np.ndarray</dt><dd><p>A 3D array with shape (3, dim, dim) representing [Sx, Sy, Sz] matrices.</p>
</dd>
</dl>
</section>
<section id="id331">
<h5>Reference:<a class="headerlink" href="#id331" title="Link to this heading"></a></h5>
<p>Quantum Mechanics: Concepts and Applications, Nouredine Zettili.</p>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">State</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">MagQunList</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumSystem.html#QuantumSystem.State"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Construct a Zeeman state vector from magnetic quantum numbers of individual spins.</p>
<section id="id332">
<h5>Parameters<a class="headerlink" href="#id332" title="Link to this heading"></a></h5>
<dl class="simple">
<dt>MagQunList<span class="classifier">dict</span></dt><dd><p>Dictionary of spin labels to their magnetic quantum numbers.</p>
</dd>
</dl>
</section>
<section id="id333">
<h5>Returns<a class="headerlink" href="#id333" title="Link to this heading"></a></h5>
<dl class="simple">
<dt>QunObj</dt><dd><p>Tensor product state corresponding to the given Zeeman state.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">State_SpinQuantumNumber</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="Source_Doc.html#Source_Doc.PyOR_QuantumObject.QunObj" title="Source_Doc.PyOR_QuantumObject.QunObj"><span class="pre">QunObj</span></a></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumSystem.html#QuantumSystem.State_SpinQuantumNumber"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Find total spin and magnetic quantum number for a system state.</p>
<section id="id334">
<h5>Parameters<a class="headerlink" href="#id334" title="Link to this heading"></a></h5>
<dl class="simple">
<dt>A<span class="classifier">QunObj</span></dt><dd><p>State vector.</p>
</dd>
</dl>
</section>
<section id="id335">
<h5>Returns<a class="headerlink" href="#id335" title="Link to this heading"></a></h5>
<dl class="simple">
<dt>tuple</dt><dd><p>(Total spin l, magnetic quantum number m)</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">State_SpinQuantumNumber_SpinOperators</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="Source_Doc.html#Source_Doc.PyOR_QuantumObject.QunObj" title="Source_Doc.PyOR_QuantumObject.QunObj"><span class="pre">QunObj</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">Ssq</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="Source_Doc.html#Source_Doc.PyOR_QuantumObject.QunObj" title="Source_Doc.PyOR_QuantumObject.QunObj"><span class="pre">QunObj</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">Sz</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="Source_Doc.html#Source_Doc.PyOR_QuantumObject.QunObj" title="Source_Doc.PyOR_QuantumObject.QunObj"><span class="pre">QunObj</span></a></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumSystem.html#QuantumSystem.State_SpinQuantumNumber_SpinOperators"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Extract spin quantum numbers from a given state and spin operators.</p>
<section id="id336">
<h5>Parameters<a class="headerlink" href="#id336" title="Link to this heading"></a></h5>
<dl class="simple">
<dt>A<span class="classifier">QunObj</span></dt><dd><p>State vector.</p>
</dd>
<dt>Ssq<span class="classifier">QunObj</span></dt><dd><p>Total spin-squared operator.</p>
</dd>
<dt>Sz<span class="classifier">QunObj</span></dt><dd><p>Total Sz operator.</p>
</dd>
</dl>
</section>
<section id="id337">
<h5>Returns<a class="headerlink" href="#id337" title="Link to this heading"></a></h5>
<dl class="simple">
<dt>tuple</dt><dd><p>(Total spin l, magnetic quantum number m)</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">States_Coupled</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">DicList</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumSystem.html#QuantumSystem.States_Coupled"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Construct tensor product state(s) from a list of Zeeman or coupled spin dictionaries.</p>
<p>Supports both simple Zeeman basis and Clebsch-Gordan combined basis (under testing).</p>
<section id="id338">
<h5>Parameters<a class="headerlink" href="#id338" title="Link to this heading"></a></h5>
<dl class="simple">
<dt>DicList<span class="classifier">list</span></dt><dd><p>List of spin label dictionaries or nested dictionaries with CG specification.</p>
</dd>
</dl>
</section>
<section id="id339">
<h5>Returns<a class="headerlink" href="#id339" title="Link to this heading"></a></h5>
<dl class="simple">
<dt>QunObj</dt><dd><p>Tensor product of eigenstates.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Update</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumSystem.html#QuantumSystem.Update"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Update system settings after parameter changes.</p>
<p>Useful after modifying B0, OMEGA_RF, OFFSET, etc.
Recomputes internal attributes used in simulation and spin labels.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ZeemanBasis_Bra</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumSystem.html#QuantumSystem.ZeemanBasis_Bra"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Return list of basis bras as strings for the full system.</p>
<section id="id340">
<h5>Returns<a class="headerlink" href="#id340" title="Link to this heading"></a></h5>
<dl class="simple">
<dt>list of str</dt><dd><p>Zeeman basis state labels like ⟨1/2,-1/2|.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ZeemanBasis_Ket</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_QuantumSystem.html#QuantumSystem.ZeemanBasis_Ket"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Return list of basis kets as strings for the full system.</p>
<section id="id341">
<h5>Returns<a class="headerlink" href="#id341" title="Link to this heading"></a></h5>
<dl class="simple">
<dt>list of str</dt><dd><p>Zeeman basis state labels like <cite>|1/2,-1/2⟩</cite>.</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
</dd></dl>

</section>
</section>
<section id="relaxation-module">
<h2>Relaxation Module<a class="headerlink" href="#relaxation-module" title="Link to this heading"></a></h2>
<section id="relaxation">
<h3><code class="xref py py-mod docutils literal notranslate"><span class="pre">Relaxation</span></code><a class="headerlink" href="#relaxation" title="Link to this heading"></a></h3>
<p>PyOR - Python On Resonance</p>
<dl>
<dt>Author:</dt><dd><p>Vineeth Francis Thalakottoor Jose Chacko</p>
</dd>
<dt>Email:</dt><dd><p><a class="reference external" href="mailto:vineethfrancis&#46;physics&#37;&#52;&#48;gmail&#46;com">vineethfrancis<span>&#46;</span>physics<span>&#64;</span>gmail<span>&#46;</span>com</a></p>
</dd>
<dt>Description:</dt><dd><p>This module defines the <cite>Relaxation</cite> class, which provides methods to model 
relaxation processes in magnetic resonance simulations.</p>
<p>The <cite>Relaxation</cite> class includes functionalities for simulating longitudinal (T1) 
and transverse (T2) relaxation, relaxation superoperators, and decoherence 
mechanisms relevant to spin dynamics.</p>
</dd>
</dl>
<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">RelaxationProcess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">class_QS</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Relaxation.html#RelaxationProcess"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Adjoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Relaxation.html#RelaxationProcess.Adjoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Return adjoint (Hermitian conjugate) of operator A</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">EigFreq_ProductOperator_H</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Hz</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">opBasis</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Relaxation.html#RelaxationProcess.EigFreq_ProductOperator_H"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute eigenfrequency in Hilbert space.</p>
<section id="id342">
<h4>Parameters:<a class="headerlink" href="#id342" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>Hz<span class="classifier">np.ndarray</span></dt><dd><p>Hamiltonian (Hilbert space)</p>
</dd>
<dt>opBasis<span class="classifier">np.ndarray</span></dt><dd><p>Operator to analyze</p>
</dd>
</dl>
</section>
<section id="id343">
<h4>Returns:<a class="headerlink" href="#id343" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>float</dt><dd><p>Eigenfrequency in Hz</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">EigFreq_ProductOperator_L</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Hz_L</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">opBasis_L</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Relaxation.html#RelaxationProcess.EigFreq_ProductOperator_L"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute the eigenfrequency of a product operator in Liouville space.</p>
<section id="id344">
<h4>Parameters:<a class="headerlink" href="#id344" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>Hz_L<span class="classifier">np.ndarray</span></dt><dd><p>Liouvillian Hamiltonian superoperator</p>
</dd>
<dt>opBasis_L<span class="classifier">np.ndarray</span></dt><dd><p>Vectorized operator (in Liouville space)</p>
</dd>
</dl>
</section>
<section id="id345">
<h4>Returns:<a class="headerlink" href="#id345" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>float</dt><dd><p>Eigenfrequency in Hz</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InnerProduct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Relaxation.html#RelaxationProcess.InnerProduct"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Inner product of two operators or vectors: ⟨A|B⟩</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Lindblad_Dissipator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Relaxation.html#RelaxationProcess.Lindblad_Dissipator"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute the Lindblad dissipator in Liouville space.</p>
<section id="id346">
<h4>Parameters:<a class="headerlink" href="#id346" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>A<span class="classifier">np.ndarray</span></dt><dd><p>Operator A</p>
</dd>
<dt>B<span class="classifier">np.ndarray</span></dt><dd><p>Operator B</p>
</dd>
</dl>
</section>
<section id="id347">
<h4>Returns:<a class="headerlink" href="#id347" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>np.ndarray</dt><dd><p>Lindblad dissipator superoperator</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Lindblad_Dissipator_Hilbert</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Relaxation.html#RelaxationProcess.Lindblad_Dissipator_Hilbert"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute Lindblad dissipator directly in Hilbert space.</p>
<section id="id348">
<h4>Parameters:<a class="headerlink" href="#id348" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>A<span class="classifier">np.ndarray</span></dt><dd><p>Operator A</p>
</dd>
<dt>B<span class="classifier">np.ndarray</span></dt><dd><p>Operator B</p>
</dd>
<dt>rho<span class="classifier">np.ndarray</span></dt><dd><p>Density matrix</p>
</dd>
</dl>
</section>
<section id="id349">
<h4>Returns:<a class="headerlink" href="#id349" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>np.ndarray</dt><dd><p>Result of applying Lindblad dissipator</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Lindblad_TemperatureGradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Relaxation.html#RelaxationProcess.Lindblad_TemperatureGradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Calculate the inverse temperature at time t for a linear temperature gradient.</p>
<section id="id350">
<h4>Parameters:<a class="headerlink" href="#id350" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>t<span class="classifier">float</span></dt><dd><p>Time (s)</p>
</dd>
</dl>
</section>
<section id="id351">
<h4>Returns:<a class="headerlink" href="#id351" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>float</dt><dd><p>Instantaneous inverse temperature</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Relaxation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Rprocess</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Relaxation.html#RelaxationProcess.Relaxation"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute the relaxation superoperator or apply relaxation to the given density matrix
based on the selected relaxation process, propagation space, and master equation.</p>
<section id="id352">
<h4>Parameters<a class="headerlink" href="#id352" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>rho<span class="classifier">ndarray, optional</span></dt><dd><p>The input density matrix to apply relaxation on. Required for Hilbert space propagation.</p>
</dd>
<dt>Rprocess<span class="classifier">str, optional</span></dt><dd><p>The relaxation model to apply. If None, the default self.Rprocess is used.
Supported options include:
- “No Relaxation”
- “Phenomenological”
- “Phenomenological Matrix”
- “Auto-correlated Random Field Fluctuation”
- “Phenomenological Random Field Fluctuation”
- “Auto-correlated Dipolar Heteronuclear Ernst”
- “Auto-correlated Dipolar Homonuclear Ernst”
- “Auto-correlated Dipolar Homonuclear”</p>
</dd>
</dl>
</section>
<section id="id353">
<h4>Returns<a class="headerlink" href="#id353" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>ndarray or QunObj</dt><dd><p>The relaxation superoperator (in Liouville space), or its action on the density matrix
(in Hilbert space), depending on the system settings.</p>
</dd>
</dl>
</section>
<section id="id354">
<h4>Notes<a class="headerlink" href="#id354" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p>MasterEquation and PropagationSpace determine how the relaxation is calculated.</p></li>
<li><p>This function supports Redfield and Lindblad equations.</p></li>
<li><p>It handles both Hilbert and Liouville space propagation.</p></li>
<li><p>For “Hilbert” space, this returns the applied relaxation: R(rho)</p></li>
<li><p>For “Liouville” space, this returns the relaxation superoperator R</p></li>
<li><p>Reference: Principles of Nuclear Magnetic Resonance in One and Two Dimensions, R. R. Ernst et al.</p></li>
</ul>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RelaxationRate_H</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">AQ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">BQ</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Relaxation.html#RelaxationProcess.RelaxationRate_H"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute relaxation rate in Hilbert space:
&lt;A|R(B)&gt; / &lt;A|A&gt;</p>
<section id="id355">
<h4>Parameters:<a class="headerlink" href="#id355" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>AQ<span class="classifier">QunObj</span></dt><dd><p>First operator A</p>
</dd>
<dt>BQ<span class="classifier">QunObj</span></dt><dd><p>Second operator B</p>
</dd>
</dl>
</section>
<section id="id356">
<h4>Returns:<a class="headerlink" href="#id356" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>float</dt><dd><p>Relaxation rate (unit depends on RProcess model)</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RelaxationRate_L</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">AQ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">BQ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Relax_LQ</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Relaxation.html#RelaxationProcess.RelaxationRate_L"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Compute relaxation rate in Liouville space:
&lt;A|R|B&gt; / &lt;A|A&gt;</p>
<section id="id357">
<h4>Parameters:<a class="headerlink" href="#id357" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>AQ<span class="classifier">QunObj</span></dt><dd><p>Operator A (Hilbert space)</p>
</dd>
<dt>BQ<span class="classifier">QunObj</span></dt><dd><p>Operator B (Hilbert space)</p>
</dd>
<dt>Relax_LQ<span class="classifier">QunObj</span></dt><dd><p>Relaxation superoperator in Liouville space</p>
</dd>
</dl>
</section>
<section id="id358">
<h4>Returns:<a class="headerlink" href="#id358" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>float</dt><dd><p>Relaxation rate</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Relaxation_CoherenceDecay</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coherence_orders</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">relaxa_rate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diagonal_relaxa_rate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default_rate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Relaxation.html#RelaxationProcess.Relaxation_CoherenceDecay"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Apply relaxation decay to selected coherence orders, with proper separation of true diagonal elements.</p>
<p>Parameters:
- coherence_orders (list or set): coherence orders to apply relaxation to (off-diagonal).
- relaxa_rate (float): relaxation rate to apply to specified off-diagonal coherence orders.
- diagonal_relaxa_rate (float): relaxation rate for true diagonal elements (population terms).
- default_rate (float): relaxation rate for all other coherence orders.</p>
<p>Returns:
- Modified coherence Zeeman array with relaxation rates applied.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpectralDensity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">W</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Relaxation.html#RelaxationProcess.SpectralDensity"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Spectral density function J(ω) for Redfield theory.</p>
<p>Reference:
Richard R. Ernst et al., “Principles of Nuclear Magnetic Resonance in One and Two Dimensions”, p.56</p>
<section id="id359">
<h4>Parameters:<a class="headerlink" href="#id359" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>W<span class="classifier">float</span></dt><dd><p>Angular frequency</p>
</dd>
<dt>tau<span class="classifier">float</span></dt><dd><p>Correlation time (s)</p>
</dd>
</dl>
</section>
<section id="id360">
<h4>Returns:<a class="headerlink" href="#id360" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>float</dt><dd><p>Spectral density J(ω)</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpectralDensity_Lb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">W</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Relaxation.html#RelaxationProcess.SpectralDensity_Lb"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Spectral density with thermal correction for Lindblad master equation.</p>
<p>Reference:
C. Bengs, M.H. Levitt, JMR 310 (2020), Eq. 140</p>
<section id="id361">
<h4>Parameters:<a class="headerlink" href="#id361" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>W<span class="classifier">float</span></dt><dd><p>Angular frequency</p>
</dd>
<dt>tau<span class="classifier">float</span></dt><dd><p>Correlation time (s)</p>
</dd>
</dl>
</section>
<section id="id362">
<h4>Returns:<a class="headerlink" href="#id362" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>float</dt><dd><p>Thermally corrected spectral density J(ω)</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Spherical_Tensor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">spin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Rank</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Sx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Sy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Sz</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Sp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Sm</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Relaxation.html#RelaxationProcess.Spherical_Tensor"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Spherical tensor components (Rank 1 and 2).</p>
<p>Reference:
S.J. Elliott, J. Chem. Phys. 150, 064315 (2019)</p>
<section id="id363">
<h4>Parameters:<a class="headerlink" href="#id363" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>spin<span class="classifier">list of int</span></dt><dd><p>Spin indices (e.g. [0,1])</p>
</dd>
<dt>Rank<span class="classifier">int</span></dt><dd><p>Tensor rank (1 or 2)</p>
</dd>
<dt>m<span class="classifier">int</span></dt><dd><p>Tensor component (-Rank to +Rank)</p>
</dd>
</dl>
</section>
<section id="id364">
<h4>Returns:<a class="headerlink" href="#id364" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>np.ndarray</dt><dd><p>Tensor operator T(Rank, m)</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Spherical_Tensor_Ernst</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">spin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Rank</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Sx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Sy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Sz</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Sp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Sm</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Relaxation.html#RelaxationProcess.Spherical_Tensor_Ernst"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Ernst-form spherical tensor operators for dipolar relaxation.</p>
<p>Reference:
Ernst et al., “Principles of Nuclear Magnetic Resonance in One and Two Dimensions”, p. 56</p>
<section id="id365">
<h4>Parameters:<a class="headerlink" href="#id365" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>spin<span class="classifier">list[int]</span></dt><dd><p>Spin indices [i, j]</p>
</dd>
<dt>Rank<span class="classifier">int</span></dt><dd><p>Tensor rank (only Rank=2 supported here)</p>
</dd>
<dt>m<span class="classifier">int</span></dt><dd><p>Component index: -2, -1, 0, 1, 2</p>
</dd>
</dl>
</section>
<section id="id366">
<h4>Returns:<a class="headerlink" href="#id366" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>np.ndarray</dt><dd><p>Spherical tensor operator T(Rank, m)</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Spherical_Tensor_Ernst_P</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">spin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Rank</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Sx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Sy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Sz</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Sp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Sm</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Relaxation.html#RelaxationProcess.Spherical_Tensor_Ernst_P"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Ernst spherical tensors with frequency label.</p>
<p>Used in relaxation models where each tensor component contributes at a specific Larmor frequency.</p>
<dl class="simple">
<dt>Returns both:</dt><dd><ul class="simple">
<li><p>Tensor operator T(Rank, m)</p></li>
<li><p>Associated frequency (for spectral density calculation)</p></li>
</ul>
</dd>
</dl>
<section id="id367">
<h4>Parameters:<a class="headerlink" href="#id367" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>spin<span class="classifier">list[int]</span></dt><dd><p>Spin indices</p>
</dd>
<dt>Rank<span class="classifier">int</span></dt><dd><p>Tensor rank (2)</p>
</dd>
<dt>m<span class="classifier">int</span></dt><dd><p>Component index or identifier (e.g. 10, 20, -11, etc.)</p>
</dd>
</dl>
</section>
<section id="id368">
<h4>Returns:<a class="headerlink" href="#id368" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>Tuple[np.ndarray, float]</dt><dd><p>Spherical tensor and its corresponding frequency in Hz</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Vector_L</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Relaxation.html#RelaxationProcess.Vector_L"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Vectorize the operator X for Liouville space calculations.</p>
</dd></dl>

</dd></dl>

</section>
</section>
<section id="rotation-module">
<h2>Rotation Module<a class="headerlink" href="#rotation-module" title="Link to this heading"></a></h2>
<section id="rotation">
<h3><code class="xref py py-mod docutils literal notranslate"><span class="pre">Rotation</span></code><a class="headerlink" href="#rotation" title="Link to this heading"></a></h3>
<p>PyOR - Python On Resonance</p>
<dl>
<dt>Author:</dt><dd><p>Vineeth Francis Thalakottoor Jose Chacko</p>
</dd>
<dt>Email:</dt><dd><p><a class="reference external" href="mailto:vineethfrancis&#46;physics&#37;&#52;&#48;gmail&#46;com">vineethfrancis<span>&#46;</span>physics<span>&#64;</span>gmail<span>&#46;</span>com</a></p>
</dd>
<dt>Description:</dt><dd><p>This module provides functions related to rotation operations in quantum mechanics 
and magnetic resonance simulations.</p>
<p>Functions include generating rotation matrices, applying rotations to quantum states 
and operators, and supporting Euler angle-based transformations.</p>
</dd>
</dl>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotateEuler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Rotation.html#RotateEuler"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Performs a rotation using Euler angles (α, β, γ) in three-dimensional space.</p>
<p>This function computes the overall rotation matrix by applying a series of three
rotations around the Z-axis, Y-axis, and Z-axis again, using the provided Euler angles:
- alpha (α) : rotation about the Z-axis
- beta (β)  : rotation about the Y-axis
- gamma (γ) : rotation about the Z-axis</p>
<p>The rotation order follows the intrinsic Tait-Bryan angle convention (Z-Y-Z), meaning:
1. Rotate by α around the Z-axis.
2. Rotate by β around the Y-axis.
3. Rotate by γ around the Z-axis again.</p>
<section id="id369">
<h4>Parameters:<a class="headerlink" href="#id369" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>alpha<span class="classifier">float</span></dt><dd><p>The angle of rotation about the Z-axis (α) in degrees.</p>
</dd>
<dt>beta<span class="classifier">float</span></dt><dd><p>The angle of rotation about the Y-axis (β) in degrees.</p>
</dd>
<dt>gamma<span class="classifier">float</span></dt><dd><p>The angle of rotation about the Z-axis (γ) in degrees.</p>
</dd>
</dl>
</section>
<section id="id370">
<h4>Returns:<a class="headerlink" href="#id370" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>numpy.ndarray</dt><dd><p>A 3x3 numpy array representing the resulting rotation matrix for the combined Euler rotations.</p>
</dd>
</dl>
</section>
<section id="id371">
<h4>Notes:<a class="headerlink" href="#id371" title="Link to this heading"></a></h4>
<p>The combined rotation is calculated as:</p>
<blockquote>
<div><p>R = RotateZ(α) * RotateY(β) * RotateZ(γ)</p>
</div></blockquote>
<dl class="simple">
<dt>where:</dt><dd><ul class="simple">
<li><p>RotateZ(α) applies a counterclockwise rotation by α around the Z-axis.</p></li>
<li><p>RotateY(β) applies a counterclockwise rotation by β around the Y-axis.</p></li>
<li><p>RotateZ(γ) applies a counterclockwise rotation by γ around the Z-axis.</p></li>
</ul>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotateX</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">theta</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Rotation.html#RotateX"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Rotates a vector or tensor about the X-axis by a given angle.</p>
<p>This function returns a 3x3 rotation matrix that can be applied to a vector or tensor
to perform a rotation about the X-axis in three-dimensional space. The angle 
<span class="math notranslate nohighlight">\(\theta\)</span> is provided in degrees and is internally converted to radians.</p>
<section id="id372">
<h4>Parameters<a class="headerlink" href="#id372" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>theta<span class="classifier">float</span></dt><dd><p>The angle of rotation in degrees. The function converts this to radians 
for the rotation calculation.</p>
</dd>
</dl>
</section>
<section id="id373">
<h4>Returns<a class="headerlink" href="#id373" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>numpy.ndarray</dt><dd><p>A 3x3 NumPy array representing the rotation matrix for a counterclockwise 
rotation about the X-axis by the angle <span class="math notranslate nohighlight">\(\theta\)</span>.</p>
</dd>
</dl>
</section>
<section id="id374">
<h4>Notes<a class="headerlink" href="#id374" title="Link to this heading"></a></h4>
<p>The rotation matrix for a counterclockwise rotation about the X-axis is:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{bmatrix}
1 &amp; 0          &amp; 0 \\
0 &amp; \cos\theta &amp; -\sin\theta \\
0 &amp; \sin\theta &amp; \cos\theta
\end{bmatrix}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\theta\)</span> is the angle of rotation in radians.</p>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotateY</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">theta</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Rotation.html#RotateY"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Rotates a vector or tensor about the Y-axis by a given angle.</p>
<p>This function returns a 3x3 rotation matrix that can be applied to a vector or tensor
to perform a rotation about the Y-axis in three-dimensional space. The angle 
<span class="math notranslate nohighlight">\(\theta\)</span> is provided in degrees and is internally converted to radians.</p>
<section id="id375">
<h4>Parameters<a class="headerlink" href="#id375" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>theta<span class="classifier">float</span></dt><dd><p>The angle of rotation in degrees. The function converts this to radians 
for the rotation calculation.</p>
</dd>
</dl>
</section>
<section id="id376">
<h4>Returns<a class="headerlink" href="#id376" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>numpy.ndarray</dt><dd><p>A 3x3 NumPy array representing the rotation matrix for a counterclockwise 
rotation about the Y-axis by the angle <span class="math notranslate nohighlight">\(\theta\)</span>.</p>
</dd>
</dl>
</section>
<section id="id377">
<h4>Notes<a class="headerlink" href="#id377" title="Link to this heading"></a></h4>
<p>The rotation matrix for a counterclockwise rotation about the Y-axis is:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{bmatrix}
\cos\theta &amp; 0 &amp; \sin\theta \\
0          &amp; 1 &amp; 0 \\
-\sin\theta &amp; 0 &amp; \cos\theta
\end{bmatrix}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\theta\)</span> is the angle of rotation in radians.</p>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotateZ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">theta</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Rotation.html#RotateZ"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Rotates a vector or tensor about the Z-axis by a given angle.</p>
<p>This function returns a 3x3 rotation matrix that can be applied to a vector or tensor
to perform a rotation about the Z-axis in three-dimensional space. The angle <span class="math notranslate nohighlight">\(\theta\)</span> is
provided in degrees and is internally converted to radians.</p>
<section id="id378">
<h4>Parameters<a class="headerlink" href="#id378" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>theta<span class="classifier">float</span></dt><dd><p>The angle of rotation in degrees. The function converts this to radians 
for the rotation calculation.</p>
</dd>
</dl>
</section>
<section id="id379">
<h4>Returns<a class="headerlink" href="#id379" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>numpy.ndarray</dt><dd><p>A 3x3 NumPy array representing the rotation matrix for a counterclockwise rotation 
about the Z-axis by the angle <span class="math notranslate nohighlight">\(\theta\)</span>.</p>
</dd>
</dl>
</section>
<section id="id380">
<h4>Notes<a class="headerlink" href="#id380" title="Link to this heading"></a></h4>
<p>The rotation matrix for a counterclockwise rotation about the Z-axis is:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{bmatrix}
\cos\theta &amp; -\sin\theta &amp; 0 \\
\sin\theta &amp;  \cos\theta &amp; 0 \\
0          &amp;  0          &amp; 1
\end{bmatrix}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\theta\)</span> is the angle of rotation in radians.</p>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Wigner_D_Matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rank</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Rotation.html#Wigner_D_Matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Computes the Wigner D-matrix for a given rank and three Euler angles (alpha, beta, gamma).</p>
<p>The Wigner D-matrix is used to describe rotations in quantum mechanics and is particularly
useful in representing the rotation of angular momentum eigenstates. The matrix is constructed
using the three Euler angles: alpha (<span class="math notranslate nohighlight">\(\alpha\)</span>), beta (<span class="math notranslate nohighlight">\(\beta\)</span>), and gamma (<span class="math notranslate nohighlight">\(\gamma\)</span>), 
which correspond to rotations around the Z-axis, Y-axis, and Z-axis again, respectively.</p>
<section id="id381">
<h4>Parameters<a class="headerlink" href="#id381" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>rank<span class="classifier">int</span></dt><dd><p>The angular momentum quantum number <span class="math notranslate nohighlight">\(l\)</span> for which the Wigner D-matrix is computed.
The resulting matrix is of size <span class="math notranslate nohighlight">\((2l + 1) \times (2l + 1)\)</span>.</p>
</dd>
<dt>alpha<span class="classifier">float</span></dt><dd><p>Rotation angle around the first Z-axis (<span class="math notranslate nohighlight">\(\alpha\)</span>) in degrees.</p>
</dd>
<dt>beta<span class="classifier">float</span></dt><dd><p>Rotation angle around the Y-axis (<span class="math notranslate nohighlight">\(\beta\)</span>) in degrees.</p>
</dd>
<dt>gamma<span class="classifier">float</span></dt><dd><p>Rotation angle around the second Z-axis (<span class="math notranslate nohighlight">\(\gamma\)</span>) in degrees.</p>
</dd>
</dl>
</section>
<section id="id382">
<h4>Returns<a class="headerlink" href="#id382" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>QunObj</dt><dd><p>A quantum object wrapping the computed Wigner D-matrix, which is a unitary matrix 
of size <span class="math notranslate nohighlight">\((2l + 1) \times (2l + 1)\)</span>.</p>
</dd>
</dl>
</section>
<section id="id383">
<h4>Notes<a class="headerlink" href="#id383" title="Link to this heading"></a></h4>
<p>The Wigner D-matrix for the given Euler angles is computed using the following expression:</p>
<div class="math notranslate nohighlight">
\[D^l_{m,m'}(\alpha, \beta, \gamma) = 
\exp(-i \alpha S_z) \cdot \exp(-i \beta S_y) \cdot \exp(-i \gamma S_z)\]</div>
<p>where:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(S_z\)</span> is the spin operator along the Z-axis.</p></li>
<li><p><span class="math notranslate nohighlight">\(S_y\)</span> is the spin operator along the Y-axis.</p></li>
<li><p>The angles <span class="math notranslate nohighlight">\(\alpha\)</span>, <span class="math notranslate nohighlight">\(\beta\)</span>, and <span class="math notranslate nohighlight">\(\gamma\)</span> are the Euler angles in <strong>radians</strong>.</p></li>
</ul>
<p>The Wigner D-matrix represents the rotation of quantum states under the specified Euler angles.</p>
</section>
<section id="see-also">
<h4>See Also<a class="headerlink" href="#see-also" title="Link to this heading"></a></h4>
<p>expm : Matrix exponential function  
QLib.SSpinOp : Generates spin operators for a given rank</p>
</section>
<section id="id384">
<h4>References<a class="headerlink" href="#id384" title="Link to this heading"></a></h4>
<ol class="arabic simple">
<li><p>Nouredine Zettili, <em>Quantum Mechanics: Concepts and Applications</em>.</p></li>
</ol>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Wigner_d_Matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rank</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_Rotation.html#Wigner_d_Matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Computes the Wigner d-matrix for a given rank and angle.</p>
<p>The Wigner d-matrix is used to represent the rotation of spherical harmonics
or quantum states under rotations in quantum mechanics. It is often used in 
various fields, including nuclear magnetic resonance (NMR) and quantum chemistry.
This function computes the Wigner d-matrix for a given rank (angular momentum quantum number)
and a rotation angle <span class="math notranslate nohighlight">\(\beta\)</span> (in degrees).</p>
<section id="id385">
<h4>Parameters<a class="headerlink" href="#id385" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>rank<span class="classifier">int</span></dt><dd><p>The rank (or angular momentum quantum number) for which the Wigner d-matrix is computed.
This corresponds to the quantum number <span class="math notranslate nohighlight">\(l\)</span> in the Wigner d-matrix formulation.</p>
</dd>
<dt>beta<span class="classifier">float</span></dt><dd><p>The rotation angle <span class="math notranslate nohighlight">\(\beta\)</span> in degrees. The function converts this to radians 
for the computation.</p>
</dd>
</dl>
</section>
<section id="id386">
<h4>Returns<a class="headerlink" href="#id386" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>QunObj</dt><dd><p>A quantum object wrapping the computed Wigner d-matrix. The matrix is unitary 
and has shape <span class="math notranslate nohighlight">\((2l + 1) \times (2l + 1)\)</span>.</p>
</dd>
</dl>
</section>
<section id="id387">
<h4>Notes<a class="headerlink" href="#id387" title="Link to this heading"></a></h4>
<p>The Wigner d-matrix <span class="math notranslate nohighlight">\(d^l_{m,m'}(\beta)\)</span> describes how spherical harmonics or 
spin states transform under rotations. In this function:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(l\)</span> is the angular momentum quantum number (rank)</p></li>
<li><p><span class="math notranslate nohighlight">\(\beta\)</span> is the rotation angle around the Y-axis, in degrees</p></li>
<li><p>The function uses the spin operator <span class="math notranslate nohighlight">\(S_y\)</span> and applies the exponential:</p></li>
</ul>
<p><span class="math notranslate nohighlight">\(\exp(-i \, \beta \, S_y)\)</span></p>
</section>
<section id="id388">
<h4>See Also<a class="headerlink" href="#id388" title="Link to this heading"></a></h4>
<p>expm : Matrix exponential function.  
QLib.SSpinOp : Function to generate spin operators.</p>
</section>
<section id="id389">
<h4>References<a class="headerlink" href="#id389" title="Link to this heading"></a></h4>
<ol class="arabic simple">
<li><p>Nouredine Zettili, <em>Quantum Mechanics: Concepts and Applications</em>.</p></li>
</ol>
</section>
</dd></dl>

</section>
</section>
<section id="signal-processing-module">
<h2>Signal Processing Module<a class="headerlink" href="#signal-processing-module" title="Link to this heading"></a></h2>
<section id="signalprocessing">
<h3><code class="xref py py-mod docutils literal notranslate"><span class="pre">SignalProcessing</span></code><a class="headerlink" href="#signalprocessing" title="Link to this heading"></a></h3>
<p>PyOR - Python On Resonance</p>
<dl>
<dt>Author:</dt><dd><p>Vineeth Francis Thalakottoor Jose Chacko</p>
</dd>
<dt>Email:</dt><dd><p><a class="reference external" href="mailto:vineethfrancis&#46;physics&#37;&#52;&#48;gmail&#46;com">vineethfrancis<span>&#46;</span>physics<span>&#64;</span>gmail<span>&#46;</span>com</a></p>
</dd>
<dt>Description:</dt><dd><p>This module provides functions for signal processing in magnetic resonance 
simulations, including time-domain and frequency-domain transformations.</p>
<p>Functions include Fourier transforms, filtering operations, phase corrections, 
and signal normalization techniques tailored for NMR and EPR data.</p>
</dd>
</dl>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">FourierTransform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zeropoints</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_SignalProcessing.html#FourierTransform"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Computes the Fourier Transform of a time-domain signal with optional zero filling.</p>
<p>This function performs a one-dimensional FFT of a signal and returns the 
frequency axis and the corresponding complex spectrum. The result is centered 
using <cite>fftshift</cite>, and zero-filling is applied to improve spectral resolution.</p>
<section id="id390">
<h4>Parameters<a class="headerlink" href="#id390" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>signal<span class="classifier">array-like</span></dt><dd><p>Time-domain signal (1D array).</p>
</dd>
<dt>fs<span class="classifier">float</span></dt><dd><p>Sampling frequency in Hz (not angular). This represents the total bandwidth.</p>
</dd>
<dt>zeropoints<span class="classifier">int</span></dt><dd><p>Zero-filling factor. Total FFT points = zeropoints × len(signal).</p>
</dd>
</dl>
</section>
<section id="id391">
<h4>Returns<a class="headerlink" href="#id391" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>freq<span class="classifier">ndarray</span></dt><dd><p>Frequency axis in Hz, centered around 0 using fftshift.</p>
</dd>
<dt>spectrum<span class="classifier">ndarray</span></dt><dd><p>Complex frequency-domain representation of the input signal.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">FourierTransform2D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fs1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fs2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zeropoints</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_SignalProcessing.html#FourierTransform2D"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Perform a 2D Fourier Transform on a 2D signal array.</p>
<p>This function is commonly used in 2D NMR to transform a time-domain 
signal into the frequency domain along both the indirect (F1) and 
direct (F2) dimensions.</p>
<section id="id392">
<h4>Parameters<a class="headerlink" href="#id392" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>signal<span class="classifier">ndarray (2D)</span></dt><dd><p>2D signal array with dimensions [F2, F1] (rows: direct, cols: indirect).</p>
</dd>
<dt>fs1<span class="classifier">float</span></dt><dd><p>Sampling frequency for the F1 (indirect) dimension.</p>
</dd>
<dt>fs2<span class="classifier">float</span></dt><dd><p>Sampling frequency for the F2 (direct) dimension.</p>
</dd>
<dt>zeropoints<span class="classifier">int</span></dt><dd><p>Zero-filling factor, multiplies each dimension size for padding.</p>
</dd>
</dl>
</section>
<section id="id393">
<h4>Returns<a class="headerlink" href="#id393" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>freq1<span class="classifier">ndarray</span></dt><dd><p>Frequency axis for the F1 (indirect) dimension.</p>
</dd>
<dt>freq2<span class="classifier">ndarray</span></dt><dd><p>Frequency axis for the F2 (direct) dimension.</p>
</dd>
<dt>spectrum<span class="classifier">ndarray (2D)</span></dt><dd><p>Complex-valued frequency-domain spectrum after 2D FFT and shift.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">FourierTransform2D_F1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zeropoints</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_SignalProcessing.html#FourierTransform2D_F1"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Perform a 1D Fourier Transform along the F1 (indirect) dimension 
of a 2D NMR signal.</p>
<p>This function applies a 1D FFT to each column (F1 dimension) of 
the signal matrix and returns the frequency axis and spectrum.</p>
<section id="id394">
<h4>Parameters<a class="headerlink" href="#id394" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>signal<span class="classifier">ndarray (2D)</span></dt><dd><p>2D time-domain signal array with dimensions [F2, F1].</p>
</dd>
<dt>fs<span class="classifier">float</span></dt><dd><p>Sampling frequency for the F1 dimension.</p>
</dd>
<dt>zeropoints<span class="classifier">int</span></dt><dd><p>Zero-filling factor for F1 dimension (not used here).</p>
</dd>
</dl>
</section>
<section id="id395">
<h4>Returns<a class="headerlink" href="#id395" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>freq<span class="classifier">ndarray</span></dt><dd><p>Frequency axis for the F1 (indirect) dimension.</p>
</dd>
<dt>spectrum<span class="classifier">ndarray (2D)</span></dt><dd><p>Transformed signal with FFT applied along F1.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">FourierTransform2D_F2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zeropoints</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_SignalProcessing.html#FourierTransform2D_F2"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Perform a 1D Fourier Transform along the F2 (direct) dimension 
of a 2D NMR signal.</p>
<p>Applies FFT row-wise (along the F2 axis) and returns the frequency axis 
and the resulting spectrum.</p>
<section id="id396">
<h4>Parameters<a class="headerlink" href="#id396" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>signal<span class="classifier">ndarray</span></dt><dd><p>2D time-domain signal array with dimensions [F2, F1].</p>
</dd>
<dt>fs<span class="classifier">float</span></dt><dd><p>Sampling frequency for the F2 (direct) dimension.</p>
</dd>
<dt>zeropoints<span class="classifier">int</span></dt><dd><p>Zero-filling factor to improve frequency resolution (multiplied to original length).</p>
</dd>
</dl>
</section>
<section id="id397">
<h4>Returns<a class="headerlink" href="#id397" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>freq<span class="classifier">ndarray</span></dt><dd><p>Frequency axis corresponding to the F2 dimension.</p>
</dd>
<dt>spectrum<span class="classifier">ndarray</span></dt><dd><p>Fourier-transformed 2D spectrum along F2.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PhaseAdjust_PH0</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">spectrum</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">PH0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_SignalProcessing.html#PhaseAdjust_PH0"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Applies zero-order phase correction to a spectrum.</p>
<p>This function performs a uniform phase shift (PH0) across the entire 
frequency-domain spectrum. This is typically used to correct for a 
constant phase error introduced by the acquisition system or processing.</p>
<section id="id398">
<h4>Parameters<a class="headerlink" href="#id398" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>spectrum<span class="classifier">ndarray</span></dt><dd><p>Complex spectrum (1D or 2D array).</p>
</dd>
<dt>PH0<span class="classifier">float</span></dt><dd><p>Zero-order phase in degrees.</p>
</dd>
</dl>
</section>
<section id="id399">
<h4>Returns<a class="headerlink" href="#id399" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>ndarray</dt><dd><p>Phase-adjusted spectrum.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PhaseAdjust_PH1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">freq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spectrum</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pivot</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slope</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_SignalProcessing.html#PhaseAdjust_PH1"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Applies first-order phase correction to a spectrum.</p>
<p>First-order phase correction applies a frequency-dependent phase shift, 
typically to correct dispersion lineshape distortions. The phase is 
zero at the <cite>pivot</cite> frequency and changes linearly with the slope.</p>
<section id="id400">
<h4>Parameters<a class="headerlink" href="#id400" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>freq<span class="classifier">ndarray</span></dt><dd><p>Frequency axis (same length as the spectrum).</p>
</dd>
<dt>spectrum<span class="classifier">ndarray</span></dt><dd><p>Complex-valued frequency-domain spectrum.</p>
</dd>
<dt>pivot<span class="classifier">float</span></dt><dd><p>Frequency (in Hz or ppm) at which the phase correction is zero.</p>
</dd>
<dt>slope<span class="classifier">float</span></dt><dd><p>Slope of the phase correction in degrees per kHz.</p>
</dd>
</dl>
</section>
<section id="id401">
<h4>Returns<a class="headerlink" href="#id401" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>ndarray</dt><dd><p>Spectrum after applying first-order phase correction.</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">WindowFunction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">LB</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_SignalProcessing.html#WindowFunction"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Applies an exponential window function to simulate signal decay.</p>
<p>This function multiplies a time-domain signal by an exponential decay factor,
typically used in signal processing to apply line broadening in NMR and other spectroscopy techniques.</p>
<section id="id402">
<h4>Parameters<a class="headerlink" href="#id402" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>t<span class="classifier">array-like</span></dt><dd><p>Time array (same length as the signal).</p>
</dd>
<dt>signal<span class="classifier">array-like</span></dt><dd><p>The input signal array to be decayed.</p>
</dd>
<dt>LB<span class="classifier">float</span></dt><dd><p>Line broadening factor (decay rate).</p>
</dd>
</dl>
</section>
<section id="id403">
<h4>Returns<a class="headerlink" href="#id403" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>array-like</dt><dd><p>The decayed signal after applying the exponential window.</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
</section>
<section id="spherical-tensors-module">
<h2>Spherical Tensors Module<a class="headerlink" href="#spherical-tensors-module" title="Link to this heading"></a></h2>
<section id="sphericaltensors">
<h3><code class="xref py py-mod docutils literal notranslate"><span class="pre">SphericalTensors</span></code><a class="headerlink" href="#sphericaltensors" title="Link to this heading"></a></h3>
<p>PyOR - Python On Resonance</p>
<dl>
<dt>Author:</dt><dd><p>Vineeth Francis Thalakottoor Jose Chacko</p>
</dd>
<dt>Email:</dt><dd><p><a class="reference external" href="mailto:vineethfrancis&#46;physics&#37;&#52;&#48;gmail&#46;com">vineethfrancis<span>&#46;</span>physics<span>&#64;</span>gmail<span>&#46;</span>com</a></p>
</dd>
<dt>Description:</dt><dd><p>This module provides functions related to spherical tensors, which are essential 
in the quantum mechanical description of angular momentum operators and their 
transformations.</p>
<p>Functions include the construction of irreducible spherical tensors, 
tensor operator manipulation, and transformation properties under rotations, 
relevant to magnetic resonance simulations.</p>
</dd>
</dl>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MatrixToSphericalTensors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">AQ</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_SphericalTensors.html#MatrixToSphericalTensors"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Converts a 3x3 Cartesian matrix into its corresponding spherical tensor components.</p>
<p>This function decomposes a Cartesian second-rank tensor (typically used in NMR or other 
physics applications) into spherical tensor components of rank 0 (isotropic), rank 1 
(antisymmetric), and rank 2 (symmetric traceless). The decomposition follows the formalism 
described in Pascal P. Man’s 2014 paper on Cartesian and spherical tensors in NMR Hamiltonians.</p>
<section id="id404">
<h4>Parameters:<a class="headerlink" href="#id404" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>AQ<span class="classifier">numpy.matrix or similar object</span></dt><dd><p>A 3x3 matrix (usually Hermitian or real) representing the Cartesian tensor 
to be converted. AQ must be a quantum object with attribute “data”.</p>
</dd>
</dl>
</section>
<section id="id405">
<h4>Returns:<a class="headerlink" href="#id405" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>dict</dt><dd><dl class="simple">
<dt>A dictionary containing the spherical tensor components:</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>“rank0”: complex</dt><dd><p>The rank-0 (isotropic) component T(0,0).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>“rank1”: list of complex</dt><dd><p>The rank-1 (antisymmetric) components [T(1,1), T(1,0), T(1,-1)].</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>“rank2”: list of complex</dt><dd><p>The rank-2 (symmetric traceless) components [T(2,2), T(2,1), T(2,0), T(2,-1), T(2,-2)].</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd>
</dl>
</section>
<section id="id406">
<h4>Reference:<a class="headerlink" href="#id406" title="Link to this heading"></a></h4>
<p>1. Pascal P. Man, “Cartesian and Spherical Tensors in NMR Hamiltonians”, 
Concepts in Magnetic Resonance Part A, 2014. <a class="reference external" href="https://doi.org/10.1002/cmr.a.21289">https://doi.org/10.1002/cmr.a.21289</a>
(Equations 275 to 281 are particularly relevant)</p>
<ol class="arabic simple" start="2">
<li><p>Tensors and Rotations in NMR, LEONARD J. MUELLER,  <a class="reference external" href="https://doi.org/10.1002/cmr.a.20224">https://doi.org/10.1002/cmr.a.20224</a></p></li>
</ol>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SphericalTensorsToMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Sptensor</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_SphericalTensors.html#SphericalTensorsToMatrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Reconstructs a 3x3 complex Cartesian matrix from its spherical tensor components.</p>
<p>This function performs the inverse operation of <cite>MatrixToSphericalTensors</cite>. It takes
a dictionary containing spherical tensor components of ranks 0 (isotropic), 1 
(antisymmetric), and 2 (symmetric traceless), and reconstructs the corresponding
Cartesian second-rank tensor as a 3x3 complex NumPy array.</p>
<section id="id407">
<h4>Parameters:<a class="headerlink" href="#id407" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>Sptensor<span class="classifier">dict</span></dt><dd><dl class="simple">
<dt>Dictionary containing spherical tensor components with the following keys:</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>‘rank0’: complex</dt><dd><p>Scalar representing the isotropic component T(0,0).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‘rank1’: list of 3 complex numbers</dt><dd><p>Antisymmetric components [T(1,1), T(1,0), T(1,-1)].</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‘rank2’: list of 5 complex numbers</dt><dd><p>Symmetric traceless components [T(2,2), T(2,1), T(2,0), T(2,-1), T(2,-2)].</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd>
</dl>
</section>
<section id="id408">
<h4>Returns:<a class="headerlink" href="#id408" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>QunObj</dt><dd><p>A custom object (assumed from context) wrapping a 3x3 complex NumPy array 
that represents the reconstructed Cartesian tensor.</p>
</dd>
</dl>
</section>
<section id="id409">
<h4>Notes:<a class="headerlink" href="#id409" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p>The spherical to Cartesian transformation follows standard NMR tensor decomposition
conventions, particularly those described in:</p></li>
<li><p>This function assumes <cite>QunObj</cite> is a class or wrapper that accepts a 3x3 complex 
NumPy array. Ensure <cite>QunObj</cite> is defined in your codebase or environment.</p></li>
</ul>
</section>
<section id="id410">
<h4>See Also:<a class="headerlink" href="#id410" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>MatrixToSphericalTensors<span class="classifier">Function that performs the forward decomposition from a </span></dt><dd><p>Cartesian tensor to spherical tensor components.</p>
</dd>
</dl>
</section>
<section id="id411">
<h4>Reference:<a class="headerlink" href="#id411" title="Link to this heading"></a></h4>
<ol class="arabic simple">
<li><p>Tensors and Rotations in NMR, LEONARD J. MUELLER,  <a class="reference external" href="https://doi.org/10.1002/cmr.a.20224">https://doi.org/10.1002/cmr.a.20224</a></p></li>
</ol>
</section>
</dd></dl>

</section>
</section>
<section id="spin-quantum-number-module">
<h2>Spin Quantum Number Module<a class="headerlink" href="#spin-quantum-number-module" title="Link to this heading"></a></h2>
<section id="spinquantumnumber">
<h3><code class="xref py py-mod docutils literal notranslate"><span class="pre">SpinQuantumNumber</span></code><a class="headerlink" href="#spinquantumnumber" title="Link to this heading"></a></h3>
<p>PyOR - Python On Resonance</p>
<dl>
<dt>Author:</dt><dd><p>Vineeth Francis Thalakottoor Jose Chacko</p>
</dd>
<dt>Email:</dt><dd><p><a class="reference external" href="mailto:vineethfrancis&#46;physics&#37;&#52;&#48;gmail&#46;com">vineethfrancis<span>&#46;</span>physics<span>&#64;</span>gmail<span>&#46;</span>com</a></p>
</dd>
<dt>Description:</dt><dd><p>This module provides spin quantum numbers for the electron and various nuclei, 
which are essential parameters for magnetic resonance simulations.</p>
<p>Spin quantum numbers are used to define the size of Hilbert spaces, 
construct spin operators, and simulate spin dynamics in NMR and EPR experiments.</p>
</dd>
</dl>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">spin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Source_Doc/PyOR_SpinQuantumNumber.html#spin"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Returns the spin quantum number of a specified particle.</p>
<p>This function looks up the spin quantum number for common particles 
(nuclei and electrons) based on predefined values. These spin quantum 
numbers are commonly used in NMR, EPR, and quantum mechanical calculations.</p>
<section id="id412">
<h4>Parameters:<a class="headerlink" href="#id412" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>value<span class="classifier">str</span></dt><dd><dl class="simple">
<dt>Symbol representing the particle. Common examples include:</dt><dd><ul class="simple">
<li><p>“E”   : Electron</p></li>
<li><p>“H1”  : Proton (Hydrogen-1)</p></li>
<li><p>“H2”  : Deuterium (Hydrogen-2)</p></li>
<li><p>“C13” : Carbon-13</p></li>
<li><p>“N14” : Nitrogen-14</p></li>
<li><p>“N15” : Nitrogen-15</p></li>
<li><p>“O17” : Oxygen-17</p></li>
<li><p>“F19” : Fluorine-19</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
</section>
<section id="id413">
<h4>Returns:<a class="headerlink" href="#id413" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>float</dt><dd><p>The spin quantum number of the given particle.</p>
</dd>
</dl>
</section>
<section id="id414">
<h4>Raises:<a class="headerlink" href="#id414" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>AssertionError</dt><dd><p>If the particle symbol is not found in the predefined <cite>SPIN</cite> dictionary.
In that case, the user is expected to define and add the spin value manually.</p>
</dd>
</dl>
</section>
<section id="id415">
<h4>Example:<a class="headerlink" href="#id415" title="Link to this heading"></a></h4>
<p>spin(“H1”)
0.5</p>
<p>spin(“O17”)
2.5</p>
</section>
<section id="id416">
<h4>Notes:<a class="headerlink" href="#id416" title="Link to this heading"></a></h4>
<p>The <cite>SPIN</cite> dictionary can be extended to include other nuclei or particles as needed.</p>
</section>
<section id="id417">
<h4>References:<a class="headerlink" href="#id417" title="Link to this heading"></a></h4>
<p>Title: NMR nomenclature. Nuclear spin properties and conventions for chemical shifts(IUPAC Recommendations 2001)
Authors: Robin K. Harris , Edwin D. Becker , Sonia M. Cabral de Menezes , Robin Goodfellow and Pierre Granger
Journal: Pure and Applied Chemistry
DOI: <a class="reference external" href="https://doi.org/10.1351/pac200173111795">https://doi.org/10.1351/pac200173111795</a></p>
</section>
</dd></dl>

</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="index.html" class="btn btn-neutral float-left" title="Welcome to PyOR’s Documentation!" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="examples.html" class="btn btn-neutral float-right" title="PyOR Simulation Examples" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Vineeth Francis Thalakottoor Jose Chacko.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>